<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue开发知乎日报]]></title>
    <url>%2F2018%2F12%2F05%2FVue%E5%BC%80%E5%8F%91%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[知乎日报项目开发知乎日报是由知乎开发的一款资讯类阅读 APP, 每日提供来自知乎社区精选的回答或者专栏文章, 本项目将使用 Vue 和 webpack 等相关技术, 利用知乎日报的接口开发一个 Web App. 分析与准备webpack 的基础配置参考 GitHub 日报是一个单页的应用, 由 3 部分组成, 如图所示: 左侧是惨淡, 分为 “每日推荐” 和 “主题日报” 两个类型, 中间是文章列表, 右侧是文章正文和评论. 其中每日推荐按日期排列, 比如途中显示为 5 月 2 日的推荐文章, 中间栏滚动至底部时. 自动加载前一天的推荐内容. 主题日报有 “日常心理学” 等 10 多个子分类, 分类列表默认是收起的, 点击 “主题日报” 菜单时切换展开和收起的状态. 点击某个子分类后, 中间栏切换为该项目下的文章列表, 不再按时间排列. 点击文章列表中的某一项, 在右侧渲染对应文章的内容和评论. 知乎日报的接口地址前缀为 http://news-at.zhihu.com/api/4/, 图片地址前缀为 https://pic1.zhimg.com, 由于两者都开启了跨域限制, 无法在前端直接调用, 因此要开发一个代理. 我们使用基于 Node.js 的 request 库来做代理, 通过 NPM 安装 request: npm install request –save-dev 在 daily 目录下新建一个 proxy.js 的文件, 写入以下内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// daily/proxy.jsconst http = require(&apos;http&apos;);const request = require(&apos;request&apos;);const hostname = &apos;127.0.0.1&apos;;const port = 8010;const imgPort = 8011;// 创建一个 API 代理服务const apiServer = http.createServer((req, res) =&gt; &#123; const url = &apos;http://news-at.zhihu.com/api/4&apos; + req.url; const options = &#123; url: url &#125;; function callback (error, response, body) &#123; if (!error &amp;&amp; response.statusCode === 200) &#123; // 设置编码类型, 否则中文会显示为乱码 res.setHeader(&apos;Content-Type&apos;, &apos;text-plain;charset=UTF-8&apos;); // 设置所有域允许跨域 res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); // 返回代理后的内容 res.end(body); &#125; &#125; request.get(options, callback);&#125;)// 监听 8010 端口apiServer.listen(port, hostname, () =&gt; &#123; console.log(`接口代理运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;);// 创建一个图片代理服务const imgServer = http.createServer((req, res) =&gt; &#123; const url = req.url.split(&apos;/img/&apos;)[1]; const options = &#123; url: url, encoding: null &#125;; function callback (error, response, body) &#123; if (!error &amp;&amp; response.statusCode === 200) &#123; const contentType = response.headers[&apos;content-type&apos;]; res.setHeader(&apos;Content-Type&apos;, contentType); res.serHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.end(body); &#125; &#125; request.get(options, callback);&#125;);// 监听 8011 端口imgServer.listen(imgPort, hostname, () =&gt; &#123; console.log(`图片代理运行在 http://$&#123;hostname&#125;:$&#123;imgPort&#125;/`)&#125;) 监听了两个端口: 8010 和 8011. 8010 用于接口代理, 8011 用于图片代理. 比如请求的真实接口为 http://news-at.zhihu.com/api/4/news/3892357, 开发时改写为 http://127.0.0.1:8080/news/3892357; 图片的真实地址为 https://pic4.zhimg.com/v2-b44636ccd2affac97ccc0759a0f64f7f.jpg, 开发时改写为 http://127.0.0.1:8011/img/https://pic4.zhimg.com/v2-b44636ccd2affac97ccc0759a0f64f7f.jpg. 代理的核心是在返回的头部 (response header) 中添加一项 Access-Control-Allow-Origin 为 “*”, 也就是允许所有的域访问. 最后在终端使用 Node 启动代理服务: node proxy.js 如果成功, 就会在终端显示两行日志: 接口代理运行在 http://127.0.0.1:8010/ 和 图片代理运行在 http://127.0.0.1:8011/ 对于接口的 Ajax 请求, 前端有多种实现方案; Vue 官方提供了 vue-resource 插件, 但是不在维护了, 而是推荐使用 axios. axios 是基于 Promise 的 HTTP 库, 同时支持前端和 Node.js. 首先使用 npm 安装 axios: npm install axios –save 在 daily 目录下新建目录 libs, 并在 libs 下新建 util.js 文件, 项目中使用的工具函数可以在这里封装. 比如对 axios 封装, 写入请求地址的前缀, 在业务中只用写相对路径, 这样可以灵活控制. 另外, 可以全局拦截 axios 返回的内容, 简单处理, 只需返回我们需要的数据. 其代码如下: 1234567891011121314151617// libs/util.jsimport axios from &apos;axios&apos;;// 基本配置const Util = &#123; imgPath: &apos;http://127.0.0.1:8011/img/&apos;, apiPath: &apos;http://127.0.0.1:8010&apos;&#125;;// Ajax 通用配置Util.ajax = axios.create(&#123; baseURL: Util.apiPath&#125;);// 添加响应拦截器Util.ajax.interceptors.response.use(res =&gt; &#123; return res.data;&#125;);export default Util; 做好这些准备后, 就可以开始日报应用的开发了. 推荐列表与分类搭建基本结构项目中使用的 css 样式不多, 所以直接写在 daily/style.css, 并在 main.js 中导入: 1234567891011// main.jsimport Vue from &apos;vue&apos;;import App from &apos;./app.vue&apos;;import &apos;./style.css&apos;;new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; &#123; return h(App) &#125;&#125;) 日报是单页应用, 没有路由, 只有一个入口组件 app.vue. 应用结构如图所示. 这里需要插入一张图片 应用分左、中、右 3 栏, 3 栏都可以滚动. 对左栏和中栏使用 fixed 固定, 并使用 overflow: auto 滚动, 而右栏高度自适应, 使用浏览器默认的 body 区域滚动即可. 基本的 HTML 和 CSS 结构如下. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// app.vue&lt;template&gt; &lt;div class=&quot;daily&quot;&gt; &lt;div class=&quot;daily-menu&quot;&gt; &lt;div class=&quot;daily-menu-item&quot;&gt;每日推荐&lt;/div&gt; &lt;div class=&quot;daily-menu-item&quot;&gt;主题日报&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;daily-list&quot;&gt; &lt;Item&gt;&lt;/Item&gt; &lt;/div&gt; &lt;daily-article&gt;&lt;/daily-article&gt; &lt;/div&gt;&lt;/template&gt;// style.csshtml, body &#123; margin: 0; padding: 0; height: 100%; color: #657180; font-size: 16px;&#125;.daily-menu &#123; width: 150px; position: fixed; top: 0; bottom: 0; left: 0; overflow: auto; background: #f5f7f9;&#125;.daily-menu-item &#123; font-size: 18px; text-align: center; margin: 5px 0; padding: 10px 0; cursor: pointer; border-right: 2px solid transparent; transition: all .3s ease-in-out;&#125;.daily-menu-item:hover&#123; background: #e3e8ee;&#125;.daily-menu-item.on &#123; border-right: 2px solid #3399ff;&#125;.daily-list &#123; width: 300px; position: fixed; top: 0; bottom: 0; left: 150px; overflow: auto; border-right: 1px solid #d7dde4;&#125;.daily-item &#123; display: block; color: inherit; text-decoration: none; padding: 16px; overflow: hidden; cursor: pointer; transition: all .3s ease-in-out;&#125;.daily-item:hover &#123; background: #e3e8ee;&#125;.daily-article &#123; margin-left: 450px; padding: 20px;&#125; 主题日报“主题日报” 下有子类列表, 默认是收起的, 点击主题日报可以切换展开和收起的状态, 使用数据 showThemes 来控制, 并用 themes 来循环渲染子类目: 12345678910111213141516171819202122232425262728293031323334353637383940414243// app.vue &lt;template&gt; &lt;div class=&quot;daily-menu&quot;&gt; &lt;div class=&quot;daily-menu-item&quot; :class=&quot;&#123; on: type === &apos;recommend&apos; &#125;&quot;&gt;每日推荐&lt;/div&gt; &lt;div class=&quot;daily-menu-item&quot; :class=&quot;&#123; on: type === &apos;daily&apos; &#125;&quot; @click=&quot;showThemes = !showThemes&quot;&gt;主题日报&lt;/div&gt; &lt;ul v-show=&quot;showThemes&quot;&gt; &lt;li v-for=&quot;item in themes&quot;&gt; &lt;a :class=&quot;&#123; on: item.id === themeId &amp;&amp; type === &apos;daily&apos; &#125;&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; themes: [], showThemes: false, type: &apos;recommend&apos;, themeId: 0 &#125; &#125;, &#125;&lt;/script&gt;// style.css.daily-menu ul&#123; list-style: none;&#125;.daily-menu ul li a &#123; display: block; color: inherit; text-decoration: none; padding: 5px 0; margin: 5px 0; cursor: pointer;&#125;.daily-menu ul li a:hover, .daily-menu ul li a.on &#123; color: #3399ff;&#125; themeId 会在点击子类时设置, 稍后会介绍. 应用初始化时, 获取主题日报的分类列表: 1234567891011121314151617181920212223// app.vue&lt;script&gt; import $ from &apos;./libs/util&apos;; export default &#123; data () &#123; return &#123; themes: [] &#125; &#125;, methods: &#123; getThemes () &#123; // axios 发起 get 请求 $.ajax.get(&apos;themes&apos;).then(res =&gt; &#123; this.themes = res.others; &#125;) &#125; &#125;, mounted () &#123; // 初始化时调用 this.getThemes(); &#125; &#125;&lt;/script&gt; 主题日报类目列表为数组, 每一项的结构示例如下: 123456789&quot;others&quot;: [ &#123; &quot;name&quot;: &quot;日常心理学&quot;, &quot;id&quot;: 13, &quot;thumbnail&quot;: &quot;http://pic3,zhimg.com/xxx.jpg&quot;, &quot;color&quot; 15007, &quot;description&quot;: &quot;了解自己和别人, 了解彼此的欲望和局限.&quot; &#125;] 点击子类目时, 将菜单 type 切换为 “主题日报” 高亮点击的子类, 然后加载该类目下的文章列表: 1234567891011121314151617181920212223242526272829303132333435363738// app.vue&lt;template&gt; &lt;ul v-show=&quot;showThemes&quot;&gt; &lt;li v-for=&quot;item in themes&quot;&gt; &lt;a :class=&quot;&#123; on: item.id === themeId &amp;&amp; type === &apos;daily&apos; &#125;&quot; @click=&quot;handleToTheme(item.id)&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; import $ from &apos;./libs/util&apos;; export default &#123; data () &#123; return &#123; themes: [], showThemes: false, type: &apos;recommend&apos;, list: [], themeId: 0 &#125; &#125;, methods: &#123; handleToTheme (id) &#123; // 改变菜单分类 this.type = &apos;daily&apos;; // 设置当前点击子类的主题日报 id this.themeId = id; // 清空中间栏的数据 this.list = []; $.ajax.get(&apos;theme/&apos; + id).then(res =&gt; &#123; // 过滤掉类型为 1 的文章, 该类型下面的文章为空 this.list = res.stories .filter(item =&gt; item.type !== 1); &#125;) &#125; &#125; &#125;&lt;/script&gt; 文章列表 list 为数组, 每一项的结构示例如下: 123456789101112131415&quot;stories&quot;: [ &#123; &quot;type&quot;: 0, &quot;id&quot;: 7097426, &quot;title&quot;: &quot;人们在虚拟生活中投入的精力是否对现实生活的人际关系有积极意义?&quot; &#125;, &#123; &quot;type&quot;: 0, &quot;id&quot;: 7101963, &quot;title&quot;: &quot;写给想成为心理咨询师的学生同仁&quot;, &quot;images&quot;: [ &quot;http://picl.zhing.com/xxx.jpg&quot; ] &#125;] 文章列表中的 id 字段是文章的 id, 请求文章内容和评论列表时会用到, title 为标题, images 为封面图片, 没有 images 字段就不显示封面图片. 每日推荐应用初始化和点击 “每日推荐” 菜单时请求推荐的文章列表. 推荐列表的 API 相对地址为 news/before/20170503, before 后面是查询的日期, 这个日期比要查询的真实日期多一天. 每日推荐可以无限次地向前一天查询, 为方便操作日期, 在 libs/util.js 内定义两个时间长发: 1234567891011121314151617181920212223242526// libs/util.jsimport axios from &apos;axios&apos;;const Util = &#123;&#125;;// 获取今天的时间戳Util.getTodayTime = function () &#123; const date = new Date(); date.setHours(0); date.setMinutes(0); date.setSeconds(0); date.setMilliseconds(0); return date.getTime();&#125;;// 获取前一天的日期Util.prevDay = function (timestamp = (new Date()).getTime()) &#123; const date = new Date(timestamp); const year = date.getFullYear(); const month = date.getMonth() + 1 &lt; 10 ? &apos;0&apos; + (date.getMonth() + 1) : date.getMonth() + 1; const day = date.getDate() &lt; 10 ? &apos;0&apos; + date.getDate() : date.getDate(); return year + &apos;&apos; + month + &apos;&apos; + day&#125;;export default Util; Util.prevDay 的参数为前一天的时间戳, 计算前一天的时间戳只需以今天 0 点的时间戳为基础, 也就是通过 Util.getTodayTime 获取的时间戳减去 86400000. 这种方法要比直接判断前一天的日期简单得多, 因为每个月的日期是不固定的, 另外还需要特殊处理闰年. 推荐文章的列表获取相关代码如下: 1234567891011121314151617181920212223242526272829303132333435363738// app.vue&lt;template&gt; &lt;div class="daily-menu-item" @click="handleToRecommend" :class="&#123; on: type === 'recommend' &#125;"&gt;每日推荐&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import $ from './libs/util' ; export default &#123; data () &#123; return &#123; type: 'recommend', recommendList: [], dailyTime: $.getTodayTime(), isLoading: false &#125; &#125;, methods: &#123; handleToRecommend () &#123; this.type = 'recommend'; this.recommendList = []; this.dailyTime = $.getTodayTime(); this.getRecommendList(); &#125;, getRecommendList () &#123; this.isLoading = true; const prevDay = $.prevDay(this.dailyTime + 86400000); $.ajax.get('news/before/' + prevDay).then(res =&gt; &#123; this.recommendList.push(res); this.isLoading = false; &#125;) &#125; &#125;, mounted () &#123; this.getRecommendList(); &#125; &#125;&lt;/script&gt; recommendList 为推荐文章列表的数据, 在初始化和每次点击 “每日推荐” 菜单时都会请求数据. dailyTime 默认获取今天 0 点的时间戳, 请求时需要多加一天. 因为推荐列表可能通过 “主题日报” 的子类切换而来, 需要重新获取一遍数据, 所以 handleToRecommend 方法每次都需要清空列表并重新设置 dailyTime. 推荐列表的数据结构和主题日报基本一致, 不同的是多了一个 date 字段来表示请求列表的日期. 两个文章列表 (list、recommendList)的每一项都用一个组件 item.vue 来展示, 在 daily/components 目录下新建 item.vue 文件, 内容如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// components/item.vue&lt;template&gt; &lt;a class="daily-item"&gt; &lt;div class="daily-img" v-if="data.images"&gt; &lt;img :src="imgPath + data.images[0]"&gt; &lt;/div&gt; &lt;div class="daily-titme" :class="&#123; noImg: !data.images &#125;"&gt;&#123;&#123; data.title &#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/template&gt;&lt;script&gt; import $ from '../libs/util' ; export default &#123; props: &#123; data: &#123; type: Object &#125; &#125;, data () &#123; return &#123; imgPath: $.imgPath &#125; &#125; &#125;&lt;/script&gt; // style.css.daily-item &#123; display: block; color: inherit; text-decoration: none; padding: 16px; overflow: hidden; cursor: pointer; transition: all .3s ease-in-out;&#125; .daily-item:hover &#123; background: #e3e8ee;&#125;.daily-img &#123; width: 80px; height: 80px; float: left;&#125;.daily-img img &#123; width: 100%; height: 100%; border-radius: 3px;&#125;.daily-title &#123; padding: 10px 5px 10px 90px;&#125;.daily-title.noImg &#123; padding-left: 5px;&#125; prop: data 里可能没有 images 字段, 所以列表会显示两种模式, 即含封面图和不含封面图. Item 组件会用到文章列表里, type 为 recommend 和 daily 两种类型下, 渲染会稍有不同. recommend 会显示每天的日期, daily 则没有. 对应的代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// app.vue&lt;template&gt; &lt;div class=&quot;daily-list&quot;&gt; &lt;template v-if=&quot;type === &apos;recommend&apos;&quot;&gt; &lt;div v-for=&quot;list in recommendList&quot;&gt; &lt;div class=&quot;daily-date&quot;&gt;&#123;&#123; formatDay(list.date) &#125;&#125;&lt;/div&gt; &lt;Item v-for=&quot;item in list.stories&quot; :data=&quot;item&quot; :key=&quot;item.id&quot;&gt;&lt;/Item&gt; &lt;/div&gt; &lt;/template&gt; &lt;template v-if=&quot;type === &apos;daily&apos;&quot;&gt; &lt;Item v-for=&quot;item in list&quot; :data=&quot;item&quot; :key=&quot;item.id&quot;&gt;&lt;/Item&gt; &lt;template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Item from &apos;./components/item.vue&apos;; export default &#123; components: &#123; Item &#125;, data () &#123; return &#123; type: &apos;recommend&apos;, recommendList: [], list: [] &#125; &#125;, methods: &#123; // 转换为带汉子的日月 formatDay (date) &#123; let month = date.substr(4, 2); let day = date.substr(6, 2); if (month.substr(0, 1) === &apos;0&apos;) month = month.substr(1, 1); if (day.substr(0, 1) === &apos;0&apos;) day = day.substr(1, 1); return `$&#123;month&#125; 月 $&#123;day&#125; 日`; &#125; &#125; &#125;&lt;/script&gt;// style.css.daily-list &#123; width: 300px; position: fixed; top: 0; bottom: 0; left: 150px; overflow: auto; border-right: 1px solid #d7dde4;&#125;.daily-date &#123; text-align: center; margin: 10px 0;&#125; 自动加载更多推荐类表]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iView经典组件剖析]]></title>
    <url>%2F2018%2F12%2F03%2FiView%E7%BB%8F%E5%85%B8%E7%BB%84%E4%BB%B6%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[级联选择组件 Cascader级联选择是网页中常见的表单类控件，主要用于省市区、公司级别、事务分类等关联数据集合的选择。 Cascader 接收一个 prop：data 作为选择面板的数据源，使用 v-model 可以双向绑定当前选择的项。 上图所示的级联选择组件示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;Cascader :data=&quot;data&quot; v-moduel=&quot;value&quot;&gt;&lt;/Cascader&gt;&lt;/template&gt;&lt;script&gt; data () &#123; return &#123; value: [&apos;jiangsu&apos;, &apos;suzhou&apos;, &apos;zhuozhengyuan&apos;], data: [&#123; value: &apos;beijing&apos;, label: &apos;北京&apos;, children: [ &#123; value: &apos;gugong&apos;, label: &apos;故宫&apos; &#125;,&#123; value: &apos;tiantan&apos;, label: &apos;天坛&apos; &#125;,&#123; value: &apos;wangfujing&apos;, label: &apos;王府井&apos; &#125; ] &#125;,&#123; value: &apos;jiangsu&apos;, label: &apos;江苏&apos;, children: [ &#123; value: &apos;nanjing&apos;, label: &apos;南京&apos;, children: [ &#123; value: &apos;fuzimiao&apos;, label: &apos;夫子庙&apos; &#125; ] &#125;, &#123; value: &apos;suzhou&apos;, label: &apos;苏州&apos;, children: [ &#123; value: &apos;zhuozhengyuan&apos;, label: &apos;拙政园&apos; &#125;, &#123; value: &apos;shizilin&apos;, label: &apos;狮子林&apos; &#125; ] &#125; ] &#125;] &#125; &#125;&lt;/script&gt; data 中的 label 是面板显示的内容， value 是它对应的值， children 是它的子集， 可以递归。 v-model 绑定一个数组， 每一项对应 data 里的 value。 开发一个通用组件最重要的是定义 API， Vue 组件的 API 来自 3 部分：prop、slot 和 event。 从功能上考虑， 先来定义 Cascader 的 prop. data：决定了级联面板的内容。 value：当前选择项， 可使用 v-model. disabled：是否禁用。 clearable：是否可清空。 placeholder：占位提示。 size：尺寸 trigger：触发方式 （点击或鼠标滑入）。 changeOnSelect： 选择即改变。 renderFormal：自定义显示内容。 对应的代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// cascader.vue&lt;script&gt; export default &#123; props: &#123; data: &#123; type: Array, default () &#123; return []; &#125; &#125;, value: &#123; type: Array, default () &#123; return []; &#125; &#125;, disabled: &#123; type: Boolean, default: false &#125;, clearable: &#123; type: Boolean, default: true &#125;, placeholder: &#123; type: String, default: &apos;请选择&apos; &#125;, size: &#123; validator (value) &#123; return oneOf(value, [&apos;small&apos;,&apos;large&apos;]); &#125; &#125;, trigger: &#123; validator (value) &#123; return oneOf(value, [&apos;click&apos;, &apos;hover&apos;]); &#125;, default: &apos;click&apos; &#125;, changeOnSelect: &#123; typeL Boolean, default: false &#125;, renderFormat: &#123; type: Function, default (label) &#123; return label.join(&apos;/&apos;); &#125; &#125; &#125; &#125;&lt;/script&gt; Cascader 的核心是用到了组件递归. 使用组件递归必不可少的两个条件是有 name 选项和在适当的时候结束递归. 图中所示的级联选择面板每一列都是一个组件 Caspanel (caspanel.vue), data 中 children 决定了每项的子集, 也就是需要递归显示 Caspanel 的数量. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// caspanel.vue&lt;template&gt; &lt;span&gt; &lt;ul v-if=&quot;data &amp;&amp; data.length&quot; :class=&quot;[prefixCls + &apos;-menu&apos;]&quot;&gt; &lt;Casitem v-for=&quot;item in data&quot; :key=&quot;item&quot; :prefix-cls=&quot;prefixCls&quot; :data=&quot;item&quot; :tmp-item=&quot;tmpItem&quot; @click.native.stop=&quot;handleClickItem(item)&quot; @mouseenter.native.stop=&quot;handleHoverItem(item)&quot;&gt;&lt;/Casitem&gt; &lt;/ul&gt; &lt;Caspanel v-if=&quot;sublist &amp;&amp; sublist.length&quot; :prefix-cls=&quot;prefixCls&quot; :data=&quot;sublist&quot; :disabled=&quot;disabled&quot; :trigger=&quot;trigger&quot; :change-on-select=&quot;changeOnSelect&quot;&gt;&lt;/Caspanel&gt; &lt;/span&gt;&lt;/template&gt;&lt;script&gt; import Casitem from &apos;./casitem.vue&apos;; export default &#123; name: &apos;Caspanel&apos;, components: &#123; Casitem &#125;, props: &#123; data: &#123; type: Array, default () &#123; return []; &#125; &#125;, disabled: Boolean, changeOnSelect: Boolean, trigger: String, prefixCls: String &#125;, data () &#123; return &#123; tmpItem: &#123;&#125;, result: [], sublist: [] &#125;; &#125;, watch: &#123; data () &#123; this.sublist = []; &#125; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack3入门]]></title>
    <url>%2F2018%2F11%2F30%2Fwebpack3%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[webpack3 入门安装 安装 nodejs 打开命令行终端, 输入一下命令, 如果出现安装版本号 ( 如: v8.11.2 ), 说明安装成功 $ node -v 安装 webpack 在命令行终端上输入以下命令, 全局安装 webpack: $ npm install webpack@3.6.0 -g npm 是 nodejs 管理插件的工具, install 表示安装, @3.6.0 表示安装指定的 webpack 版本, 如果不加@xxx, 则会默认安装最新版本; -g 表示全局安装, 这样就会把可执行文件 webpack 放到 bin 目录下, 以后就可以直接运行 webpack 目录了. 在 终端上输入以下命令, 如果输出 webpack 的版本号 ( 如 3.6.0 ), 说明安装成功. webpack -v 实现 hello world 使用 npm init 初始化项目 新建一个 hello-webpack 文件夹, 在该文件目录下打开终端, 输入下面的命令: $ npm init 之后会看到一些提示信息, 不用管, 直接全部回车, 最后, 会发现 hello-webpack 目录下多了一个名为 package.json 的文件, 内容如下: 1234567891011&#123; &quot;name&quot;: &quot;hello-webpack&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 整个 json 文件的内容很简单, 主要显示了这个项目的名称、版本、作者、协议等信息。 集成 webpack 目前项目是空的, 没有任何东西, 现在需要把 webpack 集成进来, 让这个项目可以用这个 webpack. 在终端上输入如下命令: $ npm install –save-dev webpack@3.8.1 安装成功之后会发现 package.json 文件中多了下面这几行代码: 123&quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^3.8.1&quot;&#125; 创建 JavaScript 文件 创建一个 src 目录, 然后在该目录下创建 app.js 文件, 内容如下: console.log(“Hello World”); 把 webpack 用起来 现在要把刚才的 js 文件用 weback 编译一下 新建一个 dist 目录, 编译后的文件就报错在 dist 文件中 在终端中输入下面的命令: $ webpack ./src/app.js ./dist/app.bundle.js 这个命令的意思就是把 ./src/app.js 作为源文件, 把编译后的结果放到 ./dist/app.bundle.js 文件中. 编译成功后, 我们可以在 dist 目录下看到 app.bundle.js 文件. webpack 的其他用法 上面介绍的只是 webpack 一个最简单的功能, 下面介绍一些其他的用法: –watch 首先, 在开发环境中, 如果要一边改, 一遍看转换效果, 可以使用 -watch 功能实现, 命令如下: $ webpack –watch ./src/app.js ./dist/app.bundle.js 现在改动 src/app.js 文件的内容, 就可以看到 dist/app.bundle.js 实时发生变化啦! -p 之前编译的 app.bundle.js 文件大约有 74 行代码, 差不多 2k 多的大小. 在生产环境, 或线上, 我们不希望这么大的体积, 如果要发布到线上环境, 我们要把它压缩一下. 可以使用 -p 功能来实现: 命令如下 $ webpack -p ./src/app.js ./dist/app.bundle.js 编译成功后, 可以看到 app.bundle.js 文件的体积比之前小了一些, 只有 506 个字节. webpack 配置文件 webpack.config.js虽然在命令行中使用 webpack 命令可以实现 webpack 的功能, 但我们一般是不这么做的, 我们使用配置文件来处理 创建配置文件 webpack.config.js 在 package.json 同级目录下新建 webpack.config.js 文件, 内容如下: 123456module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; filename: &apos;./dist/app.bundle.js&apos; &#125;&#125; entry 表示输入文件, output 表示输出的目标文件. 直接在终端上输入 webpack 就可以编译文件了. webpack 命令会去找 webpack.config.js 文件, 并读取它的内容, 最后进行相应的处理. 改造 package.json 的 script 部分 我们可以把一些常用的命令脚本, 比如经常要用到的 webpack 命令放到 package.json 中 修改 package.json 文件的 scripts 部分, 代码如下: 1234567&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack -d --watch&quot;, &quot;prod&quot;: &quot;webpack -p&quot; &#125;, // -d 这个参数的意思是说包含 source maps, 就是让你在用浏览器调试的时候, 可以很方便地定位到源文件 分别在命令行运行如下命令: $ npm run dev $ npm run prod 你会发现 npm run dev 和 webpack -d –watch 的效果是一样的. 这样做有如下好处: 简单维护, 所有的命令都放在一起了, 也能方便查看 别人下载了你的源码, 一查看 package.json 就能知道怎么运行这个项目 使用第一个 webpack 插件 html-webpack-plugin 创建 index.html 文件 首先, 在 dist 目录下创建 index.html 文件, 内容如下: 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Project&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;app.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样的 index.html 文件太死了, 连 js 文件都写死了, 有时候引用的 js 文件是动态变化的, 比如这样的: 1234&lt;script src=&quot;app.bundle1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;app.bundle2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;app.bundle3.js&quot;&gt;&lt;/script&gt;... ... 还有一种情况, 有时候为了更好的 cache 处理, 文件名还带着 hash, 例如这样的: main.9046fe2bf8166cbe16d7.js 这个 hash 是文件的 md5 值, 随着文件的内容而变化, 总不能每变化一次就改一下 index.html 文件吧, 效率太低了. 下面我们使用 webpack 的 html-webpack-plugin 来处理这个问题. html-webpack-plugin 安装 npm install html-webpack-plugin –save-dev 安装成功后, package.json 文件的 “devDependencies” 选项会多出来一行 “html-webpack-plugin”: “^2.30.1” 使用 现在把之前的 dist/index.html 文件先删除掉, 使用 html-webpack-plugin 插件来自动生成它. 修改 webpack.config.js 文件, 如下: 123456789101112const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &apos;./src/app.js&apos;, output: &#123; path: __dirname + &apos;/dist&apos;, filename: &apos;./dist/app.bundle.js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(), ]&#125;; 最后, 运行一下 npm run dev 命令, 会发现在 dist 目录下生成了 index.html 文件. 更好的使用 html-webpack-plugin 打开 index.html 文件可以看到, 连标题 Webpack App 都自动生成了. 如果不想要这样默认的标题怎么办呢? 要改变 title 很简单, HtmlWebpackPlugin 这个方法可以传入很多参数, 下面这样就可以解决这个问题 123456... ...plugins: [ new HtmlWebpackPlugin(&#123; title: &quot;hello world&quot; &#125;),] 重新生成 index.html 文件, 可以看到标题已经改变了. 有时候我们要让 index.html 根据我们的意愿来生成. 就是说它的内容是我们自己定的. 可以使用 html-webpack-plugin 的 template 功能来实现, 修改 webpack.config.js 如下: 1234567... ...plugins: [ new HtmlWebpackPlugin(&#123; title: &quot;hello world&quot;, template: &apos;./src/index.html&apos;, &#125;),] 接着新建 src/index.html 文件, 内容如下: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行 npm run dev 生成的 dist/index.html 文件内容如下: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./dist/app.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面在看看其他几个参数及结果 filename: “index.html” 默认情况下生成的 html 文件叫 index.html, 如果不想叫这个名字, 可以修改 minify: { ​ collapseWhitespace: true, } // 这个可以把生成的 index.html 文件的内容的没用的空格去掉, 减少空间. hash: true 为了更好的 cache, 可以在文件名后加个 hash. 如: src=”./dist/app.bundle.js?0b5552db1f811f9c43e0” 123456789101112// 最后的 webpack.config.js 内容如下所示... ... plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos;, filename: &apos;index.html&apos;, minify: &#123; collapseWhitespace: true, &#125;, hash: true, &#125;),] html-webpack-plugin 还有很多其他用法和选项, 参考官方文档. 使用 loader 处理 CSS 和 Sass 什么是 loader 官方的解释是这样的: loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 其实就是处理文件的, 比如把 Scss 转化成 CSS, TypeScript 转化成 JavaScript 等. 用 css-loader 和 style-loader 处理 CSS 新建 app.css 文件并在 app.js 文件中引入 12345678// src/app.cssbody &#123; background: pink;&#125;// src/app.jsimport css from &apos;./app.css&apos;;console.log(&quot;hello world&quot;); 如果现在运行 npm run dev 或者 webpack 命令, 会出现 You may need an appropriate loader to handle this file type. 这样的报错信息. 意思是说, 默认情况下, webpack 处理不了 CSS 的东西, 你需要一个 loader 来处理这个类型的文件. 安装 css-loader 和 style-loader $ npm install css-loader style-loader –save-dev 在 webpack.config.js 文件中进行配置 123456789101112module.exports = &#123; ... ... module: &#123; rules: [ &#123; // 意思是说, 当检测到 .css 结尾的文件时, 使用 style-loader 和 css-loader 来处理 test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125; ] &#125;&#125; 现在再使用 npm run dev 编译一下, 打开 dist/index.html 可以看到背景色已经变成了粉色了. 编译出来的 app.bundle.js 是包含 CSS 内容的. 用 sass-loader 把 SASS 编译成 CSS 修改文件 123456789101112131415// src/app.scss 将 src/app.css 改名为 src/app.scssbody &#123; background: pink; p &#123; color: red; &#125;&#125;// src/index.html&lt;body&gt; &lt;p&gt;Hello world&lt;/p&gt;&lt;/body&gt; // src/app.jsimport css from &apos;./app.scss&apos;; 安装 sass-loader 和node-sass $ npm install sass-loader node-sass –save-dev 1234567891011// webpack.config.js... ...module: &#123; rules: [ ... ... &#123; test: /\.scss$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos; ] &#125; ]&#125; 打包完成后可以看到 p 标签内的文本变成了红色的 使用 extract-text-webpack-plugin 把 CSS 分离成文件 有时候我们要把 SASS 或者 CSS 处理好后, 放到一个 CSS 文件中, 可以使用这个插件来实现 $ npm install extract-text-webpack-plugin –save-dev 1234567891011121314151617181920// webpack.config.jsconst ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);module.exports = &#123; ... ... plugins: [ ... ... new ExtractTextPlugin(&apos;style.css&apos;) ], module: &#123; rules: [ &#123; test: /\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [ &apos;css-loader&apos;, &apos;sass-loader&apos; ] &#125;) &#125; ] &#125;&#125; 这样编译后就在 dist 目录下生成了 style.css 文件. 并且可以在 index.html 文件中看到 style.css 是通过 link 的方式引入进来的. 初识 webpack-dev-server一般来说, webpack-dev-server 这个插件在开发环境都会使用到. 我们之前使用 webpack -d –watch 来在开发环境下编译静态文件, 这个功能完全可以使用 webpack-dev-server 来代替. 除此之外, webpack-dev-derver 还有其他功能, 比如在本地开启服务、打开浏览器等. 安装 1234// 首先全局安装$ npm install webpack-dev-server -g// 然后项目本地安装$ npm install webpack-dev-server --save-dev 运行命令 $ webpack-dev-server 如果看到 The CLI moved into a separate package: webpack-cli 这个报错信息, 根据提示下载 webpack-cli $ npm install webpack-cli -D 再次运行 webpack-dev-server 命令, 如果看到 throw new Error(‘invalid “instanceof” keyword value ‘ + c); 这个报错信息, 可能是 webpack 版本与 webpack-dev-server 版本不兼容 ( 这里的 webpack 是 ^3.8.1 版本的, webpack-dev-server 是 ^3.1.10 版本的 ); 重新下载一个版本的 webpack-dev-server, 例如 ( ^2.11.3 ) $ npm install webpack-dev-server@2.11.3 –save-dev 再次运行 webpack-dev-server 命令, 可以看到 Project is running at http://localhost:8080/ 提示信息 打开浏览器, 输入 localhost:8080, 可以看到和以前一样的效果. 修改默认端口 项目默认是运行在 8080 端口上的, 这个我们可以修改 1234567891011// webpack.config.jsmodule.exports = &#123; ... ... devServer: &#123; // 修改端口 port: 9000, // 还可以配置一运行 webpack-dev-server 的时候就会自动打开浏览器 open: true &#125;, ... ...&#125; 使用 webpack 和 babel 配置 react 开发环境 安装 react 要使用 react, 就必须安装下面两个包 $ npm install react react-dom –save 建立 babel 你可以把 babel 理解为编译器, 它能把 react 代码转成一般浏览器可读可执行的代码, 通常可以用来转化 react 或 vue 这样的前端代码, 或者把 ES6 代码转化成普通的 JavaScript 代码 要让 babel 很好的转化 react 代码, 首先要安装好 babel, 再安装 babel 转化 react 的包 $ npm install babel-core babel-preset-react babel-preset-env –save-dev 创建 .babelrc 文件 123&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]&#125; 在 webpack 使用 babel-loader 最后我们需要在 webpack 中使用一个 loader 来转化 react 的代码 首先,安装 $ npm install babel-loader –save-dev 然后进行配置 123456789// webpack.config.jsmodule: &#123; rules: [ ... ... // 这两行是处理 react 相关的内容 &#123; test: /\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, &#123; test: /\.jsx$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/ &#125; ]&#125; 写 react 组件 准备一些 react 的代码, 来测试一下 1234567891011121314151617181920212223242526272829303132333435// src/index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;// src/app.js... ... import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import Root from &apos;./Root&apos;;ReactDOM.render( &lt;Root&gt;&lt;/Root&gt;, document.getElementById(&apos;root&apos;));// src/Root.jsimport React from &apos;react&apos;;export default class Root extends React.Component &#123; render () &#123; return ( &lt;div style=&#123;&#123;textAlign: &apos;center&apos;&#125;&#125;&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 修改版本问题 由于安装的 babel-core^6.26.3 版本与 babel-loader^8.0.4 版本不匹配, 所以运行 webpack-dev-server 出现了如下错误: babel-loader@8 requires Babel 7.x (the package ‘@babel/core’). If you’d like to use Babel 6.x (‘babel-core’), you should install ‘babel-loader@7’. 根据提示重新安装 babel-loader $ npm install babel-loader@7.1.5 –save-dev 重新运行 webpack-dev-server 命令, 可以看到浏览器自动打开并展示出了期望的页面样式. 使用 clean-webpack-plugin 来清除文件一般这个插件是配合 webpack -p 这条命令来清除文件使用的, 就是说在为生产环境编译文件的时候, 先把 build 或 dist ( 就是放生产环境用的文件 ) 目录里的文件先清除干净, 在生成新的. 为什么要使用 clean-webpack-plugin 插件 我们来通过一个例子了解一下 12345678910111213// webpack.config.jsconst path = require(&apos;path&apos;)... ...module.exports = &#123; entry: &#123; &quot;app.bundle&quot;: &apos;./src/app.js&apos; &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[chunkhash].js&apos; &#125;, ... ...&#125; 在终端上运行: $ npm run prod 12345// 可以看到 dist 目录下生成了 app.bundle.14fe4a2f90cf9a717bbd.js 文件dist├── app.bundle.14fe4a2f90cf9a717bbd.js├── index.html└── style.css 再把 src/app.js 的内容改改, 然后再执行 npm run prod, 多运行几次可以发现, 生成的带 hash 的 app.bundle.js 文件很多 123456dist├── app.bundle.0e380cea371d050137cd.js├── app.bundle.259c34c1603489ef3572.js├── app.bundle.14fe4a2f90cf9a717bbd.js├── index.html└── style.css 这些带 hash 的 app.bundle.js 只有最新的才有用, 其他的都没用, 我们要在 build 之前把他们全都清空, clean-webpack-plugin 插件就是用来干这个的. 使用 clean-webpack-plugin 首先安装 $ npm install clean-webpack-plugin –save-dev 然后配置 1234567891011121314151617181920212223// webpack.config.jsconst path = require(&apos;path&apos;)... ...const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);let pathsToClean = [ &apos;dist&apos;,]module.exports = &#123; entry: &#123; &quot;app.bundle&quot;: &apos;./src/app.js&apos; &#125;, outPut: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].[chunkhash].js&apos; &#125;, ... ... plugins: [ new CleanWebpackPlugin(pathsToClean), ... ... ]&#125; 在运行 npm run dev 可以发现, dist 目录下新生成的 文件只有一个了 1234dist├── app.bundle.3ccf5544bcda830c4ec5.js├── index.html└── style.css 配置多个 HTML 文件之前我们只写了一个 html 文件, 就是 src/index.html, 但是有时候我们是需要多个的, 这个时候该怎么办呢? 之前我们是这样做的, 用了 html-webpack-plugin 这个插件来输出 html 文件. 1234567891011// webpack.config.js... ...new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos;, filename: &apos;index.html&apos;, minify: &#123; collapseWhitespace: true, &#125;, hash: true,&#125;)... ... 我们现在还这么做, 只需要改个名字就好了. 123456789101112131415161718192021222324252627282930// webpack.config.js... ...new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos;, filename: &apos;index.html&apos;, minify: &#123; collapseWhitespace: true, &#125;, hash: true,&#125;),new HtmlWebpackPlugin(&#123; template: &apos;./src/contact.html&apos;, filename: &apos;contact.html&apos;, minify: &#123; collapseWhitespace: true, &#125;, hash: true,&#125;)// src/contact.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Contact&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Contact Page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 有个问题, contact.html 使用的 js 和 css 跟 index.html 是一模一样的. 如果我们要让 contact.html 使用跟 index.html 不同的 js, 可以这样来改造一下: ( 只要保证 js 不同, css 也会不同的, 因为 css 是由 js 里 import 的 ) 123456789101112131415161718192021222324252627282930313233... ...module.exports = &#123; entry: &#123; &quot;app.bundle&quot;: &apos;./src/app.js&apos;, // 这行是新增的 &quot;contact&quot;: &apos;./src/contact.js&apos; &#125;, ... ... plugins: [ new CleanWebpackPlugin(pathsToClean), new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos;, filename: &apos;index.html&apos;, minify: &#123; collapseWhitespace: true, &#125;, hash: true, // 这行是新增的 excludeChunks: [&apos;contact&apos;] &#125;), new HtmlWebpackPlugin(&#123; template: &apos;./src/contact.html&apos;, filename: &apos;contact.html&apos;, minify: &#123; collapseWhitespace: true, &#125;, hash: true, // 这行是新增的 chunks: [&apos;contact&apos;] &#125;), new ExtractTextPlugin(&apos;style.css&apos;) ]&#125; 上面的 excludeChunks 指的是不包含, chunks 代表的是包含. // src/contact.js console.log( ‘hi from contact.js’ ) 结果可以看到, contact 页面里面引用的就只有 contact.js 了. 如何使用 pug (jade) 作为 HTML 的模板什么是 pug? 如果是 nodejs 程序员的话, 肯定听过 jade 吧, pug 就是从 jade 改名过来的. 说白了, 它就是可以让你以更好的语法来写 html. 我们来看看下面的例子 现在我们要代替之前的 src/index.html 改用 pug 语法来写. 首先把 src/index.html 改名叫 src/index.pug // 使用命令行重命名 $ rename src/index.html src/index.pug 1234567891011121314151617181920// src/index.pugdoctype htmlhtml(lang=&quot;en&quot;) head title= pageTitle script(type=&apos;text/javascript&apos;). if (foo) bar(1+5) body h1 Pug - node template engine #root #container.col if youAreUsingPug p You are amazing else p Get on it! p. Pug is a terse and simple templating language with a strong focus on performance and powerful features. // 这里要注意 .pug 文件的内容书写格式// 如果运行命令后出现了 Invalid indentation, you can use tabs or spaces but not both 这个报错信息, 说明书写缩进格式有问题, 可以统一修改成使用空格缩进. 上面的内容是从 pug 官方的示例中抄的 12345678910111213141516171819// webpack.config.js... ...module.exports = &#123; ... ... plugins: [ ... ... new HtmlWebpackPlugin(&#123; template: &apos;./src/index.pug&apos;, ... ... &#125;), ... ... ], module: &#123; rules: [ ... ... &#123; test: /\.pug$/, loader: [&apos;raw-loader&apos;, &apos;pug-html-loader&apos;] &#125; ] &#125;&#125;; 安装 pug $ npm install –save-dev pug pug-html-loader raw-loader 现在可以启动服务, 打开页面看看效果. 现在来试试 pug 的 include 功能, 就是可以包含子模板. 12345678910111213141516171819// src/index.pug... ...body include includes/header.pug ... ... // src/includes/header.pugh1 from header pug file// 目录结构是这样的src├── Root.js├── app.js├── app.scss├── contact.html├── contact.js├── includes│ └── header.pug└── index.pug 现在再来启动服务来看看效果.]]></content>
      <categories>
        <category>-前端</category>
      </categories>
      <tags>
        <tag>-webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发软件]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[常用开发软件 编辑器:WebStormVSCode小工具ScreenToGif​ 一个可以录制 GIF 图片的开源工具，同时还具备编辑帧、调用摄像头录制、录制画板等功能。 ​ 下载链接 MarkMan​ 测量图片像素尺寸, 抓取颜色值等 ​ 下载链接: PostmanMockPlus]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>软件 工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue+Koa2移动电商项目学习笔记(二)]]></title>
    <url>%2F2018%2F07%2F26%2FVue%2BKoa2%E7%A7%BB%E5%8A%A8%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20(%20%E4%BA%8C%20)%2F</url>
    <content type="text"><![CDATA[在项目中安装 Koa2在项目中安装 Koa 和 MongoDB 首先在项目根目录下建立文件夹 service，并进入文件夹 使用 npm init -y 生成并初始化 package.js 文件 在命令行使用 npm 来安装 koa npm install –save koa 编写一个 Hello World 测试安装是否成功 1234567891011// service 目录下新建 index.jsconst Koa = require( &apos;koa&apos; )const app = new Koa()app.use(async(ctx)=&gt;&#123; ctx.body = &apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;&#125;)app.listen(3000,()=&gt;&#123; console.log(&apos;[Server] starting at port 3000&apos;)&#125;) 编写好后，使用 node index.js 来启动服务，然后在浏览器中输入 http://localhost:3000，如果正常显示 hello world，说明 koa2 已经安装成功啦。 安装 MongoDB 数据库安装步骤 在官网下载 MongoDB 下载之后进行安装，选择默认安装 安装时如果有安全软件报拦截一律允许就好啦，否则胡安装失败 安装完成后，需要配置 “环境变量”， 目的是在命令行中直接使用，而不用驶入很长的路径 运行 MongoDB 服务端 安装好 MongoDB 数据库之后，需要启用服务端才能使用。启用服务的命令是： Mongod 打开命令行： win + R ===&gt; cmd 执行 mongod ： 在命令中直接输入 mongod，会发现服务并没有启动，报了一个 exception，服务停止 新建文件夹：出现上面的错误，是因为还没有建立 MongoDB 需要的文件夹，一般是安装盘的根目录，建立 data/db，这两个文件夹 运行 mongod：这时候服务就可以开启了，链接默认端口是 27017 下载 Robo3 由于我们是做项目，所以图形界面比较直观，我们上边没有安装图形界面，这里使用 Robo3 来弥补一下 下载地址：Robo3 然后就是下一步下一步安装 Koa 用 Mongoose 连接数据库 (1)Mongoose 概念 Mongoose 是一个开源的封装好的实现 Node 和 MongoDB 数据通讯的数据建模库 Mongoose 安装 npm install mongoose –save // 使用 npm 进行安装 连接数据库 在项目 service 文件夹下新建一个 database 文件夹，用来存放和数据库操作相关的文件。 在 database 文件夹下， 新建一个 init.js 文件，用来做数据库的连接和一些初始化的事情 12345678910111213141516171819202122232425262728// /service/database/init.jsconst mongoose = require(&apos;mongoose&apos;)const db = &quot;mongodb://localhost/simle-db&quot; mongoose.Promise = global.Promise exports.connect = ()=&gt;&#123; //连接数据库 mongoose.connect(db) //增加数据库连接的事件监听 mongoose.connection.on(&apos;disconnected&apos;,()=&gt;&#123; //进行重连 mongoose.connect(db) &#125;) //数据库出现错误的时候 mongoose.connection.on(&apos;error&apos;,err=&gt;&#123; console.log(err) mongoose.connect(db) &#125;) //链接打开的时候 mongoose.connection.once(&apos;open&apos;,()=&gt;&#123; console.log(&apos;MongoDB Connected successfully!&apos;) &#125;) &#125; 然后在 /service/index.js 里加入立即执行函数，在使用之前要使用 require 进行引入 connect 1234567//引入connectconst &#123;connect&#125; = require(&apos;./database/init.js&apos;) //立即执行函数;(async () =&gt;&#123; await connect()&#125;)() 然后在终端中运行 node index.js 命令，就可以看到数据库已经连接成功了 Koa 用 Mongoose 连接数据库 (2)前面已经做了基本的数据库连接，并且已经连接成功。但是如果数据没有开启，或者网络出现问题，我们并没有做这些意外处理，在写程序时，当主要功能完成时，我们要作意外处理和逻辑处理，让程序增加健壮性 增加 Promise 支持 在做 init.js 文件时，必须确保先连接数据库后，在做其他事情，所以需要在所有代码的外层增加一个 Promise 123return new Promise ((resolve,reject)=&gt;&#123; // 把所有连接放在这里&#125;) 连接失败自动重连 一般数据库连接失败，我们会重新连接，但这个重连也是需要有一个次数的，比如连接 3 次失败，我们在服务端抛出异常 首先声明一个最大连接数 maxConnectTimes. let maxConnectTimes = 0 当连接断开时，进行重连的代码如下 1234567891011mongoose.connection.on(&apos;disconnected&apos;,()=&gt;&#123; console.log(&apos;***********数据库断开***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject() throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) 当连接断开时，需要把连接次数 +1，并重连数据库。当重连次数超过 3 次后，我们抛出异常，并用 reject() 通知 Promise 同样当连接出错时，我们也要进行重新连接操作 1234567891011mongoose.connection.on(&apos;error&apos;,err=&gt;&#123; console.log(&apos;***********数据库错误***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject(err) throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) 全部文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445const mongoose = require(&apos;mongoose&apos;)const db = &quot;mongodb://localhost/smile-db&quot; exports.connect = ()=&gt;&#123; //连接数据库 mongoose.connect(db) let maxConnectTimes = 0 return new Promise((resolve,reject)=&gt;&#123; //把所有连接放到这里 //增加数据库监听事件 mongoose.connection.on(&apos;disconnected&apos;,()=&gt;&#123; console.log(&apos;***********数据库断开***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject() throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) mongoose.connection.on(&apos;error&apos;,err=&gt;&#123; console.log(&apos;***********数据库错误***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject(err) throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) //链接打开的时 mongoose.connection.once(&apos;open&apos;,()=&gt;&#123; console.log(&apos;MongoDB connected successfully&apos;) resolve() &#125;) &#125;) &#125; Mongoose 的 Schema 建模数据库已经可以连接成功了，现在我们来了解一下如何建模，也就是定义 Schema，相当于 MongoDB 数据库的一个映射。 Schema 是一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力。 Schema 是以 key-value 形式 json 格式的数据。 Schema 中的数据类型 String：字符串类型 Number：数字类型 Date：日期类型 Boolean：布尔类型 Buffer：NodeJS buffer 类型 ObjectID：主键，一种特殊而非常重要的类型 Mixed：混合类型 Array：集合类型 Mongoose 中的三个概念 schema：用来定义表的模板，实现和 MongoDB 数据库的映射。用来实现每个字段的类型，长度，映射的字段，不具备表的操作能力。 model： 具备某张表操作能力的一个集合，是 mongoose 的核心能力。 entity： 类似记录，由 Model 创建的实体，也具有数据库的操作能力。 初学定义一个用户 Schema 我们先以用户表为例，定义一个基本数据模型，( 当然并不完善，后面会逐步完善这个模型，并加入一些安全的机制进去 ) 在 /service/database/ 文件夹下新建一个 schema 文件夹， 然后新建一个 User.js 文件。 12345678910111213141516const mongoose = require(&apos;mongoose&apos;) //引入Mongooseconst Schema = mongoose.Schema //声明Schemalet ObjectId = Schema.Types.ObjectId //声明Object类型 //创建我们的用户Schemaconst userSchema = new Schema(&#123; UserId:ObjectId, userName:&#123;unique:true,type:String&#125;, password:String, createAt:&#123;type:Date,default:Date.now()&#125;, lastLoginAt:&#123;type:Date,default:Date.now()&#125; &#125;) //发布模型mongoose.model(&apos;User&apos;,userSchema) 载入 Schema 和插入查出数据Schema 建立好以后，需要载入这些数据库，最好的方法就是在后台服务已启动的时候就把载入做好，所以在 service/init.js 里做这件事情，然后在 index.js 里直接执行 载入所有 Schema 在 service/init.js 引入一个 glob 和一个 resolve 首先安装 glob npm install glob –save const glob = require(‘glob’) const { resolve } = require(‘path’) glob：node 的 glob 模块允许使用 * 等符号，来写一个 glob 规则，像在 shell 里一样，获取匹配对应规则文件 resolve：将一系列路径或路径段解析为绝对路径 1234// 了解两个引入的模块用法后，就可以一次性引入所有的 Schema 文件了。exports.initSchemas = () =&gt; &#123; glob.sync( resolve(__dirname, &apos;./schema/&apos;, &apos;**/*.js&apos;)).forEach(require)&#125; 插入一条数据 在操作数据库之前先引入我们的 Mongoose 和 刚写好的 initSchemas 12const mongoose = require(&apos;mongoose&apos;)const &#123;connect , initSchemas&#125; = require(&apos;./database/init.js&apos;) 引入好后，直接在 service/index.js 的立即执行函数里插入一条 User 数据 12345678910;(async () =&gt;&#123; await connect() initSchemas() const User = mongoose.model(&apos;User&apos;) let oneUser = new User(&#123;userName:&apos;jspang&apos;,password:&apos;123456&apos;&#125;) oneUser.save().then(()=&gt;&#123; console.log(&apos;插入成功&apos;) &#125;) &#125;)() 读出已经插入进去的数据 12345let users = await User.findOne(&#123;&#125;).exec()console.log(&apos;------------------&apos;)console.log(users)console.log(&apos;------------------&apos;)// 这里只读出了一条，我们也可以试着读出多条 完整的 index.js 代码如下: 12345678910111213141516171819202122232425262728293031const Koa = require(&apos;koa&apos;)const app = new Koa()const mongoose = require(&apos;mongoose&apos;)const &#123;connect , initSchemas&#125; = require(&apos;./database/init.js&apos;) //立即执行函数;(async () =&gt;&#123; await connect() initSchemas() const User = mongoose.model(&apos;User&apos;) let oneUser = new User(&#123;userName:&apos;jspang13&apos;,password:&apos;123456&apos;&#125;) oneUser.save().then(()=&gt;&#123; console.log(&apos;插入成功&apos;) &#125;)let users = await User.findOne(&#123;&#125;).exec() console.log(&apos;------------------&apos;)console.log(users)console.log(&apos;------------------&apos;) &#125;)() app.use(async(ctx)=&gt;&#123; ctx.body = &apos;&lt;h1&gt;hello Koa2&lt;/h1&gt;&apos;&#125;) app.listen(3000,()=&gt;&#123; console.log(&apos;[Server] starting at port 3000&apos;)&#125;) 打造安全的用户密码加密机制加密处理 密码加密有很多种算法，比如 MD5 加密或者 hash256 加密算法；可以通过 哈希加密算法 这个网站直观地了解一下加密算法 加盐处理 有时候用户的密码设置的太过简单，很容易受到暴力破解或者用彩虹表破解。这时候就要使用加盐技术了，其实就是在原来的密码里，加入一些其他的字符串，并且我们可以自己设置加入字符串的强度。 把加盐的数据库密码进行 hash 处理后，在存入数据库就比较安全了 bcrypt 的使用 bcrypt 是一种跨平台的文件加密工具。有它加密的文件可在所有支持的操作系统和处理器上进行转译。它的口令必须是 8 至 56 个字符，并将在内部被转化为 448 位的密钥 使用 npm 进行安装 // 安装在 service 文件夹里面 npm install –save –registry=https://registry.npm.taobao.org ​ 因为 bcrypt 里边的二进制包的下载可能被墙掉了，可以尝试使用淘宝源来进行安装 引入 bcrypt const bcrypt = require( ‘bcrype’ ) // /service/database/schema/User.js 文件 用 pre 每次进行保存时都进行加盐加密的操作 12345678910111213141516/* /service/database/schema/User.js 文件 *///每次存储数据时都要执行userSchema.pre(&apos;save&apos;, function(next)&#123; // let user = this // console.log(this) bcrypt.genSalt( SALT_WORK_FACTOR,(err,salt)=&gt;&#123; if(err) return next(err) bcrypt.hash(this.password,salt, (err,hash)=&gt;&#123; if(err) return next(err) this.password = hash next() &#125;) &#125;)&#125;) 编写注册页面前端视图注册页面的 vue 模板编写 新建页面 首先，来新建一个 vue 的模板文件： src/components/pages/Register.vue 编写 vue 的路由配置文件 router/index.js 12345678910111213import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import ShoppingMall from &apos;@/components/pages/ShoppingMall&apos;import Register from &apos;@/components/pages/Register&apos; Vue.use(Router) export default new Router(&#123; routes: [ &#123;path: &apos;/&apos;,name: &apos;ShoppingMall&apos;,component: ShoppingMall&#125;, &#123;path: &apos;/register&apos;,name: &apos;Register&apos;,component: Register&#125;, ]&#125;) 引入 Vant 的两个插件 Field 和 NavBar 123// main.jsimport &#123; Button, Row, Col, Search, Swipe, SwipeItem, Lazyload, List, Field, NavBar &#125; from &apos;vant&apos;Vue.use(Button).use(Row).use(Col).use(Search).use(Swipe).use(SwipeItem).use(Lazyload).use(List).use(Field).use(NavBar) 编写模板文件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;用户注册&quot; left-text=&quot;返回&quot; left-arrow @click-left=&quot;goBack&quot; /&gt; &lt;div class=&quot;register-panel&quot;&gt; &lt;van-field v-model=&quot;username&quot; label=&quot;用户名&quot; icon=&quot;clear&quot; placeholder=&quot;请输入用户名&quot; required @click-icon=&quot;username = &apos;&apos;&quot; /&gt; &lt;van-field v-model=&quot;password&quot; type=&quot;password&quot; label=&quot;密码&quot; placeholder=&quot;请输入密码&quot; required /&gt; &lt;div class=&quot;register-button&quot;&gt; &lt;van-button type=&quot;primary&quot; size=&quot;large&quot;&gt;马上注册&lt;/van-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; username: &apos;&apos;, password: &apos;&apos;, &#125; &#125;, methods: &#123; goBack() &#123; this.$router.go(-1) &#125; &#125;, &#125;&lt;/script&gt; &lt;style scoped&gt; .register-panel&#123; width:96%; border-radius: 5px; margin:20px auto; padding-bottom:50px; &#125; .register-button&#123; padding-top:10px; &#125;&lt;/style&gt; Koa2 的用户操作的路由模块化把所有的路由都写在 service/index.js 里是不正确的选择，这回导致我们的 index.js 页面越来越臃肿，最后变得没办法维护。我们需要把 Koa 程序模块化，也叫做路由模块化 安装 Koa-router 进入到 service 文件夹下，打开命令行，使用 npm 安装： npm install koa-router –save // 这里下载的版本是 7.4.0 新建一个 User.js 文件 新建一个 appApi 文件夹，然后进入文件夹，新建 user.js 文件。有关 User.js 的操作，以后都会放到这个文件下，就是要编写的供前台使用的接口程序 编写 user.js 文件： 123456789const Router = require ( &apos;koa-router&apos; )let router = new Router()router.get(&apos;/&apos;,async(ctx)=&gt;&#123; ctx.body = &quot;这是用户操作首页&quot;&#125;)router.get(&apos;/register&apos;,async(ctx)=&gt;&#123; ctx.body = &quot;用户注册接口&quot;&#125;)module.exports = router; 让路由模块化 首先在 index.js 的文件顶部，引入 koa-router const Router = require(‘koa-router’) 引入 user.js 模块 let user = require(‘./appApi/user.js’) 装载所有子路由 let router = new Router(); router.use(‘/user’,user.routes()) 加载路由中间件 app.use(router.routes()) app.use(router.allowedMethods()) 做完这四步，我们就可以在浏览器中试一下我们的模块化路由是否起作用了，在浏览器中输入 localhost:3000/user，已经可以出现我们设定好的页面了 ( 需要首先使用 node index.js 启动服务 ) 总结： 通过这种简单的模块化路由机制，我们就实现了文件的分离，当然这并不是最完美的方案，如果对要求比较高的朋友，可以看一下 egg.js 的路由写法或者直接使用 egg.js 来进行开发。当然现在这种做法完全可以应付小型项目的开发 打通注册用户的前后端通讯这一步的主要作用是 使用 API 接口的形式可以在前后端互相通讯和传递数据 安装 koa-bodyparser 中间件 首先要接到前端发过来的请求，这时候需要安装 koa-bodyparser 中间件，进入到 server 目录下，使用 npm 来进行安装 npm install –save koa-bodyparser // 这里安装的是 4.2.1 版本 安装好之后， 在 service/index.js 文件中注册和引入中间件 const bodyParser = require( ‘koa-bodyparser’ ) app.use(bodyParser()); 前台的 axios 请求数据 在 register.vue 头部引入 axios import axios from ‘axios’ 修改 serviceAPI.config.js 接口配置文件 需要对接口配置文件做一些设置。加入我们的注册接口地址 1234567891011const BASEURL = &quot;https://www.easy-mock.com/mock/5ae2eeb23fbbf24d8cd7f0b6/SmileVue/&quot;const LOCALURL = &quot;http://localhost:3000/&quot;const URL = &#123; getShoppingMallInfo:BASEURL+&apos;index&apos;, getGoodsInfo:BASEURL+&apos;getGoodsInfo&apos;, registerUser:LOCALURL+&apos;user/register&apos;, //用户注册接口&#125; module.exports = URL// 这里主要加入了 LOCALURL 常量的声明，用于存储本地请求路径，和在 URL 里增加了 registerUser 接口的地址配置 引入接口配置文件 import url from ‘@/serviceAPI.config.js’ 编写 axios 用户注册方法 12345678910111213141516171819// 将下面的代码写在 src/components/pages/Register.vue 文件下的 methods 属性里面//*********axios注册用户方法********axiosRegisterUser()&#123; axios(&#123; url: url.registerUser, method: &apos;post&apos;, data:&#123; username:this.username, password:this.password &#125; &#125;) .then(response =&gt; &#123; console.log(response) &#125;) .catch((error) =&gt; &#123; console.log(error) &#125;)&#125; 给注册按钮绑定 axiosRegisterUser 方法 马上注册 让 koa2 支持跨域请求 安装 koa2-cors 中间件 在 koa2 里解决跨域的中间件叫 koa2-cors，先进入到 service 文件夹，使用 npm 来进行安装 npm install –save koa2-cors 在 service/index.js 文件中引入和注册 (使用) 中间件： const cors = require( ‘koa2-cors’ ) app.use(cors()) 编写 koa2 接收前台数据的方法 现在前台和后台数据互通的基本环节已经做好了，我们再写一个后台的数据接口方法，就可以实现接收数据，并回传数据了 进入 service/appApi/user.js 文件，修改 register 路由接口下的代码，记得把 get 方法换成 post 方法。 1234router.post(&apos;/register&apos;,async(ctx)=&gt;&#123; console.log(ctx.request.body) ctx.body = ctx.request.body&#125;) 至此我们已经完成了前后台数据的互通，现在我们可以打开服务接口，开启浏览器测试一下 用户注册数据库操作Koa2 的 User.js 接口的完善 首先在 service/appApi/user.js 下引入 mongose，这样就可以操作我们的 Schema 了。 const mongoose = require(‘mongoose’) 编写 register 接口的程序 12345678910111213141516171819202122router.post(&apos;/register&apos;,async(ctx)=&gt;&#123; //取得Model const User = mongoose.model(&apos;User&apos;) //把从前端接收的POST数据封装成一个新的user对象 let newUser = new User(ctx.request.body) //用mongoose的save方法直接存储，然后判断是否成功，返回相应的结果 await newUser.save().then(()=&gt;&#123; //成功返回code=200，并返回成功信息 ctx.body=&#123; code:200, message:&apos;注册成功&apos; &#125; &#125;).catch(error=&gt;&#123; //失败返回code=500，并返回错误信息 ctx.body=&#123; code:500, message:error &#125; &#125;) &#125;) 前端 vue 的业务处理 前面我们只是使用 axios 发送了一个请求，对返回的结果只是简单的 console.log 了一下，现在我们把这些代码进行补全，根据 koa 端返回的 code 进行不同的提示。 我们可以使用 Vant 的轻提示插件 Toast，先引入 Tosat 组件，直接在 Register.vue 下引入就可以了 import { Toast } from ‘vant’ 具体业务逻辑代码如下： 12345678910111213141516171819202122232425axiosRegisterUser()&#123; axios(&#123; url: url.registerUser, method: &apos;post&apos;, data:&#123; userName:this.username, password:this.password &#125; &#125;) .then(response =&gt; &#123; console.log(response) //如果返回code为200，代表注册成功，我们给用户作Toast提示 if(response.data.code == 200)&#123; Toast.success(&apos;注册成功&apos;) &#125;else&#123; console.log(response.data.message) Toast.fail(&apos;注册失败&apos;) &#125; console.log(response.data.code) &#125;) .catch((error) =&gt; &#123; Toast.fail(&apos;注册失败&apos;) &#125;) &#125; 然后可以测试一下，看看是否可以插入数据库，并给用户一个有好的提示 注册的防重复提交1. 在按钮上绑定 loading 属性 首先打开 src/components/pages/Register.vue 文件，找到注册按钮，然后在按钮上绑定 loadding 属性 马上注册 然后在线面的 JavaScript 部分的 data 中声明 openLoading 属性 1234567data() &#123; return &#123; username: &apos;&apos;, password: &apos;&apos;, openLoading: false, //是否开启用户的Loading &#125;&#125;, 2. 改写注册方法 防重复提交要在进入注册业务逻辑的时候就开始实行，也就是点击注册按钮这一步时。所以我们现在要改造已经写好的 axiosRegisterUser() 方法，加入一些防重复提交的逻辑 12345678910111213141516171819202122232425axios(&#123; url: url.registerUser, method: &apos;post&apos;, data:&#123; userName:this.username, password:this.password &#125;&#125;).then(response =&gt; &#123; console.log(response) //如果返回code为200，代表注册成功，我们给用户作Toast提示 if(response.data.code == 200)&#123; Toast.success(&apos;注册成功&apos;) this.$router.push(&apos;/&apos;) &#125;else&#123; console.log(response.data.message) Toast.fail(&apos;注册失败&apos;) this.openLoading=false &#125; &#125;).catch((error) =&gt; &#123; Toast.fail(&apos;注册失败&apos;) this.openLoading=false&#125;) 在一开始进入注册方法的时候，做的第一件事就是把注册按钮变成 loading 状态。然后在注册失败的时候取消 loading 状态，注册成功就跳转到个人中心页面 (这部分还没做). 这样在前台就防止了重复提交 解决一个小问题 在程序中定义的是 user 而真实数据库中变成了 users，我们可以在 Schema 里配置一下解决这个问题 打开 service/database/schema/User.js 修改 new 之后的代码。 加入 { collection: ‘user’ } 123456789const userSchema = new Schema(&#123; UserId:ObjectId, userName:&#123;unique:true,type:String&#125;, password:String, createAt:&#123;type:Date,default:Date.now()&#125;, lastLoginAt:&#123;type:Date,default:Date.now()&#125;,&#125;,&#123; collection:&apos;user&apos;&#125;) 注册时的前端验证1. 首先为 Field 绑定 error-message 属性 vant 框架提供的 field 属性提供了错误提示的机制，就是 error-message 属性。先在 script 的 data 里注册两个属性， usernameErrorMsg 和 passwordErrorMsg。 当值不符时，作用户提示使用。 123456789101112// 在 template 里面的相应位置添加上 :error-message = &quot;usernameErrorMsg&quot; 和 :error-message = &quot;passwordErrorMsg&quot;data()&#123; return &#123; username: &apos;&apos;, passwoed: &apos;&apos;, openLoading: false, // 是否开启用户的 Loading usernameErrorMsg: &apos;&apos;, // 当用户名出错的时候 passwordErrorMsg: &apos;&apos; // 当密码出错的时候 &#125;&#125;// 开始这两个值都为空，不给用户任何操作提示，只有按下注册按钮时才进行检测提示 2. 编写验证方法 checkForm 在 methods 里增加一个 checkForm() 方法，用来验证表单信息，代码如下： 12345678910111213141516checkForm()&#123; let isOk = true if(this.username.length &lt; 5)&#123; // 验证用户名不能少于 5 位 this.usernameErrorMsg = &quot;用户名不能小于 5 位&quot; isOk = false &#125; else &#123; this.usernameErrorMsg = &quot;&quot; &#125; if(this.password.length &lt; 6)&#123; // 验证密码不能少于 6 位 this.passwordErrorMsg = &quot;密码不能少于 6 位&quot; isOK = false &#125; else &#123; this.passwordErrorMsg = &quot;&quot; &#125; return isOk&#125; 3. 重新编写注册方法 这时我们把一个注册分为了两个业务逻辑，第一步是检验表单数据，第二步向端口发送数据等待结果。如果直接在以前的 axiosRegisterUser() 方法上改造显得很不优雅，代码会很长，维护起来会增加额外的成本。新建一个 registerAction() 方法。 123registerAction()&#123; this.checkForm() &amp;&amp; this.axiosRegisterUser()&#125;, 4. 重新绑定注册按钮事件 原来的按钮事件直接调用了 axiosRegisterUser() 方法，这时候我们要更换为新的 registerAction() 方法。 马上注册 Vue 的登陆界面制作和路由配置1. 新建 Login.vue 文件 在 src/components/pages 文件夹下新建 Login.vue 文件。 因为登录页和注册页样式基本相同，所以可以直接复制注册页代码 然后进行修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;template&gt; &lt;div&gt; &lt;van-nav-bar title=&quot;用户登录&quot; left-text=&quot;返回&quot; left-arrow @click-left=&quot;goBack&quot; /&gt; &lt;div class=&quot;register-panel&quot;&gt; &lt;van-field v-model=&quot;username&quot; label=&quot;用户名&quot; icon=&quot;clear&quot; placeholder=&quot;请输入用户名&quot; required @click-icon=&quot;username = &apos;&apos;&quot; :error-message=&quot;usernameErrorMsg&quot; /&gt; &lt;van-field v-model=&quot;password&quot; type=&quot;password&quot; label=&quot;密码&quot; placeholder=&quot;请输入密码&quot; :error-message=&quot;passwordErrorMsg&quot; required /&gt; &lt;div class=&quot;register-button&quot;&gt; &lt;van-button type=&quot;primary&quot; @click=&quot;LoginAction&quot; :loading=&quot;openLoading&quot; size=&quot;large&quot;&gt;登录&lt;/van-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from &apos;axios&apos; import url from &apos;@/serviceAPI.config.js&apos; import &#123; Toast &#125; from &apos;vant&apos; export default &#123; data() &#123; return &#123; username: &apos;&apos;, password: &apos;&apos;, openLoading: false, //是否开启用户的Loading usernameErrorMsg:&apos;&apos;, //当用户名出现错误的时候 passwordErrorMsg:&apos;&apos;, //当密码出现错误的时候 &#125; &#125;, methods: &#123; goBack() &#123; this.$router.go(-1) &#125;, //*****注册用户的实行方法***** LoginAction()&#123; this.checkForm() &amp;&amp; this.axiosLoginUser() &#125;, //*******axios注册用户方法******* axioLoginUser()&#123; //先把按钮进行loading状态，防止重复提交 this.openLoading = true axios(&#123; url: url.registerUser, method: &apos;post&apos;, data:&#123; userName:this.username, password:this.password &#125; &#125;) .then(response =&gt; &#123; &#125;) .catch((error) =&gt; &#123; &#125;) &#125;, //**** 客户端验证 checkForm()&#123; let isOk= true if(this.username.length&lt;5)&#123; this.usernameErrorMsg=&quot;用户名不能小于5位&quot; isOk= false &#125;else&#123; this.usernameErrorMsg=&apos;&apos; &#125; if(this.password.length&lt;6)&#123; this.passwordErrorMsg=&quot;密码不能少于6位&quot; isOk= false &#125;else&#123; this.passwordErrorMsg=&apos;&apos; &#125; return isOk &#125; &#125;, &#125;&lt;/script&gt;&lt;style scoped&gt; .register-panel&#123; width:96%; border-radius: 5px; margin:20px auto; padding-bottom:50px; &#125; .register-button&#123; padding-top:10px; &#125;&lt;/style 2. 配置路由，让页面可以正常访问 打开 /src/router/index.js 页面，配置路由，代码如下 123456789101112131415import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import ShoppingMall from &apos;@/components/pages/ShoppingMall&apos;import Register from &apos;@/components/pages/Register&apos;import Login from &apos;@/components/pages/Login&apos; Vue.use(Router) export default new Router(&#123; routes: [ &#123;path: &apos;/&apos;,name: &apos;ShoppingMall&apos;,component: ShoppingMall&#125;, &#123;path: &apos;/register&apos;,name: &apos;Register&apos;,component: Register&#125;, &#123;path: &apos;/login&apos;,name: &apos;Login&apos;,component: Login&#125;, ]&#125;) 配置好之后启动服务，打开 http://localhost:8080/#/login 进行测试。 登陆的服务端业务逻辑代码登陆业务的简单业务逻辑就是得到前端发来的用户名和密码，然后跟数据库进行比对，如果正确就显示登陆成功，失败就显示登陆失败 Schema中的对比实例方法 需要在 Schema 中制作一个比对的实例方法，这个方法就是比对我们加盐加密后的密码的。在 service/database/schema/User.js 中增加下面的代码： 12345678910111213userSchema.methods = &#123; // 密码比对的方法 comparePassword:(_password,password) =&gt; &#123; return new Promise((resolve,reject) =&gt;&#123; bcrypt.compare(_password,password,(err,isMatch) =&gt; &#123; if (!err) resolve(isMatch) else reject(err) &#125;) &#125;) &#125;&#125;// 这段代码声明了一个实例方法，方法叫做 comparePassword， 然后传递两个参数，一个是客户端密码，一个是数据库取出来的密码。用 bcrypt 提供的 compare 方法就可以比对，最后包装成 Promise 返回就可以了。 编写登陆的 API 接口 进入 service/appApi/user.js，增加一个 login 路由， 并在路由内写入业务逻辑代码。 1234567891011121314151617181920212223242526272829303132333435/*登录的实践 */router.post(&apos;/login&apos;,async(ctx)=&gt;&#123; //得到前端传递过来的数据 let loginUser = ctx.request.body console.log(loginUser) let userName = loginUser.userName let password = loginUser.password //引入User的model const User = mongoose.model(&apos;User&apos;) //查找用户名是否存在，如果存在开始比对密码 await User.findOne(&#123;userName:userName&#125;).exec().then(async(result)=&gt;&#123; console.log(result) if(result)&#123; //console.log(User) //当用户名存在时，开始比对密码 let newUser = new User() //因为是实例方法，所以要new出对象，才能调用 await newUser.comparePassword(password,result.password) .then( (isMatch)=&gt;&#123; //返回比对结果 ctx.body=&#123; code:200, message:isMatch&#125; &#125;) .catch(error=&gt;&#123; //出现异常，返回异常 console.log(error) ctx.body=&#123; code:500, message:error&#125; &#125;) &#125;else&#123; ctx.body=&#123; code:200, message:&apos;用户名不存在&apos;&#125; &#125; &#125;).catch(error=&gt;&#123; console.log(error) ctx.body=&#123; code:500, message:error &#125; &#125;)&#125;) 前后端结合调试 在 src/serviceAPI.config.js 下加入接口代码。 12345678910const BASEURL = &quot;https://www.easy-mock.com/mock/5ae2eeb23fbbf24d8cd7f0b6/SmileVue/&quot;const LOCALURL = &quot;http://localhost:3000/&quot;const URL = &#123; getShoppingMallInfo:BASEURL+&apos;index&apos;, getGoodsInfo:BASEURL+&apos;getGoodsInfo&apos;, registerUser:LOCALURL+&apos;user/register&apos;, //用户注册接口 login:LOCALURL+&apos;user/login&apos;, //用户注册接口&#125; module.exports = URL 修改 src/components/pages/Login.vue 把 axios 的 Url 改成我们的 login 接口地址。 然后打开浏览器进行调试，就会得到成功与不成功。 登录的前端交互效果制作和登录状态存储前端交互效果制作 目前为止从 Koa2 服务端是可以取到登录结果的，但是前端只是简单的打印了出来，并没有做任何交互。我们要在返回登录成功时，给用户一个 Toast 提示，并跳转到首页 ( 个人中心页面，暂未做 )，当返回登录失败的时候，要提示用户登录失败，并把登录按钮重新启用，可以再次登录 在 /src/components/pages/Login.vue 的 axiosLoginUser 方法里修改代码如下： 12345678910111213141516171819202122232425262728axiosLoginUser()&#123; // 先把注册按钮进行 loading 状态，防止重复提交 this.openLoading = true; axios(&#123; url: url.login, method: &apos;post&apos;, data: &#123; userName: this.username, password: this.password &#125; &#125;) .then(response =&gt; &#123; console.log(response) if (response.data.code == 200 &amp;&amp; response.data.message)&#123; Toast.success(&apos;登录成功!&apos;) this.$router.push(&apos;/&apos;) &#125; else &#123; Toast.fail(&apos;登录失败!&apos;) this.openLoading = false &#125; &#125;) .catch((error) =&gt; &#123; console.log(error); Toast.fail(&apos;登录失败!&apos;) this.openLoading = false &#125;)&#125;, 保存用户登录状态 移动端的应用有一个特殊的地方，就是当用户登录一次后，下次就不用登录了。这时候登录的信息是存储到了本地的 LocalStorage 里了。这个操作要等取到正确的登陆状态以后再执行，也就是要在 axios 返回了登录成功结果以后执行。代码如下： 123456789101112new Promise((resolve,reject) =&gt; &#123; localStorage.userInfo = &#123;userName: this.username&#125; setTimeout(()=&gt;&#123; resolve() &#125;,500)&#125;).then(()=&gt;&#123; Toast.success(&apos;登录成功!&apos;) this.$router.push(&apos;/&apos;)&#125;).catch(err=&gt;&#123; Toast.fail(&apos;登录状态保存失败&apos;) console.log(err)&#125;) 我们保存了用户登录状态以后，就有了一个是否登录的依据，然后我们就不会重复登录了，我们在已进入登录页面的 created 生命周期里，就判断是否已经登录。 123456created()&#123; if(localStorage.userInfo)&#123; Toast.success(&apos;您已经登录了&apos;) this.$router.push(&apos;/&apos;) &#125;&#125;, 这时候如果已经登录后，再去登录页他会直接跳转到首页，并且提示你已经登录过了。 这步做完后 Login.vue 页面 script 部分完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import axios from &apos;axios&apos;import url from &apos;@/serviceAPI.config.js&apos;import &#123; Toast &#125; from &apos;vant&apos;export default &#123; data() &#123; return &#123; username: &apos;&apos;, password: &apos;&apos;, openLoading: false, //是否开启用户的Loading usernameErrorMsg:&apos;&apos;, //当用户名出现错误的时候 passwordErrorMsg:&apos;&apos;, //当密码出现错误的时候 &#125; &#125;, created()&#123; if(localStorage.userInfo)&#123; Toast.success(&apos;您已经登录过了!&apos;) this.$router.push(&apos;/&apos;); &#125; &#125;, methods: &#123; goBack() &#123; this.$router.go(-1) &#125;, //*****注册用户的实行方法***** LoginAction()&#123; this.checkForm() &amp;&amp; this.axiosLoginUser() &#125;, //*******axios注册用户方法******* axiosLoginUser()&#123; //先把按钮进行loading状态，防止重复提交 this.openLoading = true axios(&#123; url: url.login, method: &apos;post&apos;, data:&#123; userName:this.username, password:this.password &#125; &#125;).then(response =&gt; &#123; //如果返回code为200，代表注册成功，我们给用户作Toast提示 if(response.data.code == 200 &amp;&amp; response.data.message)&#123; new Promise((resolve,reject) =&gt; &#123; localStorage.userInfo = &#123;userName: this.username&#125; setTimeout(()=&gt;&#123;resolve()&#125;,500) &#125;).then(()=&gt;&#123; Toast.success(&apos;登录成功&apos;) this.$router.push(&apos;/&apos;) &#125;).catch(err=&gt;&#123; Toast.fail(&apos;登录状态保存失败&apos;) console.log(err) &#125;) &#125;else&#123; console.log(response.data.message) Toast.fail(&apos;登陆失败&apos;) this.openLoading = false &#125; &#125;).catch((error) =&gt; &#123; Toast.fail(&apos;登陆失败&apos;) this.openLoading = false &#125;) &#125;, //**** 客户端验证 checkForm()&#123; let isOk= true if(this.username.length&lt;5)&#123; this.usernameErrorMsg=&quot;用户名不能小于5位&quot; isOk= false &#125;else&#123; this.usernameErrorMsg=&apos;&apos; &#125; if(this.password.length&lt;6)&#123; this.passwordErrorMsg=&quot;密码不能少于6位&quot; isOk= false &#125;else&#123; this.passwordErrorMsg=&apos;&apos; &#125; return isOk &#125; &#125;,&#125; 商品详细数据的提纯操作现在开始准备页面的商品数据和类别数据，目的是制作列表页和详情页。我们需要在 5W 多条商品详情的 JSON 数据中把有用的数据筛选出来，这种筛选叫做数据的提纯。 用 fs 读入数据 在 service 文件夹下，新建一个 fsJson.js 的文件使用 node 的 fs 模块，可以轻松把文件读取到程序中，然后进行遍历，把有用的数据提取出来，写入到一个新的数组中。代码如下： 123456789101112131415const fs = require(&apos;fs&apos;)fs.readFile(&apos;.goods.json&apos;,&apos;utf8&apos;,function(err,data)&#123; let newData = JSON.parse(data); let i = 0; let pushData = []; newData.RECORDS.map(function(value,index)&#123; if(value.IMAGE1 != null)&#123; i++; console.log(value.NAME); pushData.push(value); &#125; &#125;) console.log(i); console.log(pushData);&#125;) 写入到新的文件中 1234fs.writeFile(&apos;./newGoods.json&apos;,JSON.stringify(pushData),function(err)&#123; if(err) console.log(&apos;写入文件失败!&apos;); else console.log(&apos;写入文件操作成功&apos;);&#125;) 这样就完成了这次数据的提纯操作，通过提纯我们得到了一张可用的 json 商品详情表。 通过这节的学习主要是了解一下 node 的 fs 模块，这在工作中是非常常用的。 12345678910111213141516171819202122// fsJson.js 文件完整代码：const fs = require(&apos;fs&apos;);fs.readFile(&apos;.goods.json&apos;, &apos;utf8&apos;, function(err, data)&#123; let newData= JSON.parse(data) let i=0; let pushData=[]; newData.RECORDS.map(function(value,index)&#123; if(value.IMAGE1!=null)&#123; i++; console.log(value.NAME); pushData.push(value); &#125; &#125;); console.log(i); console.log(pushData); fs.writeFile(&apos;./newGoods.json&apos;,JSON.stringify(pushData),function(err)&#123; if(err) console.log(&apos;写文件操作失败&apos;); else console.log(&apos;写文件操作成功&apos;); &#125;);&#125;); 批量插入商品详情数据到 MongoDB 中有了可插入的 JSON 数据，就可以建立一个 Schema 模型， 然后是用 Mongoose 插入到我们的数据库中。 1. 建立 Goods 的 Schema 建立 service/database/schema/Goods.js 文件，然后根据我们的数据表结构建立模型。代码如下： 123456789101112131415161718192021222324252627282930313233343536const mongoose = require(&apos;mongoose&apos;) // 引入 Mongooseconst Schema = mongoose.Schema // 声明 Schemalet ObjectId = Schema.Types.ObjectId // 声明 Object 类型const goodsSchema = new Schema(&#123; ID:&#123;unique:true,type:String&#125;, GOODS_SERIAL_NUMBER:String, SHOP_ID:String, SUB_ID:String, GOOD_TYPE:Number, STATE:Number, NAME:String, ORI_PRICE:Number, PRESENT_PRICE:Number, AMOUNT:Number, DETAIL:String, BRIEF:String, SALES_COUNT:Number, IMAGE1:String, IMAGE2:String, IMAGE3:String, IMAGE4:String, IMAGE5:String, ORIGIN_PLACE:String, GOOD_SCENT:String, CREATE_TIME:String, UPDATE_TIME:String, IS_RECOMMEND:Number, PICTURE_COMPERSS_PATH:String&#125;,&#123; collections:&apos;Goods&apos;&#125;)mongoose.model(&apos;Goods&apos;,goodsSchema)// 这里需要注意的是，要安装我们 JSON 中的数据进行建立。 2. 批量插入数据库的路由方法 新建一个 service/appApi/goods.js 以后关于商品的操作就都在这个 api 文件中编写了，我们也是要写路由的形式，提供每一个支持。 12345678910111213141516171819202122232425262728const Koa = require(&apos;koa&apos;);const app = new Koa();const Router = require(&apos;koa-router&apos;);let router = new Router();const mongoose = require(&apos;mongoose&apos;);const fs = require(&apos;fs&apos;);router.get(&apos;/insertAllGoodsInfo&apos;,async(ctx)=&gt;&#123; fs.readFile(&apos;./goods.json&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123; data = JSON.parse(data); let saveCount = 0; const Goods = mongoose.model(&apos;Goods&apos;); data.map((value,index)=&gt;&#123; console.log(value); let newGoods = new Goods(value); newGoods.save().then(()=&gt;&#123; saveCount++; console.log(&apos;成功&apos; + saveCount) &#125;).catch(error =&gt; &#123; console.log(&apos;失败：&apos; + error) &#125;) &#125;) &#125;) ctx.body = &quot;开始导入数据!&quot;&#125;)module.exports = router; 3. 把路由加入到 index.js 里 写好了 goods.js 的路由方法，就可以把它暴露到 index.js 里了 1234// /service/index.jslet goods = require(&apos;./appApi/goods.js&apos;);router.use(&apos;/goods&apos;,goods.routes()) 做完这一步，就可以在浏览器运行一下 http://localhost:3000/goods/insertAllGoodsInfo，运行结束后，可以到数据库看一下插入情况批量插入商品详情数据到 MongoDB 中 有了可插入的 JSON 数据，就可以建立一个 Schema 模型， 然后是用 Mongoose 插入到我们的数据库中。 1. 建立 Goods 的 Schema 建立 service/database/schema/Goods.js 文件，然后根据我们的数据表结构建立模型。代码如下： 123456789101112131415161718192021222324252627282930313233343536const mongoose = require(&apos;mongoose&apos;) // 引入 Mongooseconst Schema = mongoose.Schema // 声明 Schemalet ObjectId = Schema.Types.ObjectId // 声明 Object 类型const goodsSchema = new Schema(&#123; ID:&#123;unique:true,type:String&#125;, GOODS_SERIAL_NUMBER:String, SHOP_ID:String, SUB_ID:String, GOOD_TYPE:Number, STATE:Number, NAME:String, ORI_PRICE:Number, PRESENT_PRICE:Number, AMOUNT:Number, DETAIL:String, BRIEF:String, SALES_COUNT:Number, IMAGE1:String, IMAGE2:String, IMAGE3:String, IMAGE4:String, IMAGE5:String, ORIGIN_PLACE:String, GOOD_SCENT:String, CREATE_TIME:String, UPDATE_TIME:String, IS_RECOMMEND:Number, PICTURE_COMPERSS_PATH:String&#125;,&#123; collections:&apos;Goods&apos;&#125;)mongoose.model(&apos;Goods&apos;,goodsSchema)// 这里需要注意的是，要安装我们 JSON 中的数据进行建立。 2. 批量插入数据库的路由方法 新建一个 service/appApi/goods.js 以后关于商品的操作就都在这个 api 文件中编写了，我们也是要写路由的形式，提供每一个支持。 12345678910111213141516171819202122232425262728const Koa = require(&apos;koa&apos;);const app = new Koa();const Router = require(&apos;koa-router&apos;);let router = new Router();const mongoose = require(&apos;mongoose&apos;);const fs = require(&apos;fs&apos;);router.get(&apos;/insertAllGoodsInfo&apos;,async(ctx)=&gt;&#123; fs.readFile(&apos;./goods.json&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123; data = JSON.parse(data); let saveCount = 0; const Goods = mongoose.model(&apos;Goods&apos;); data.map((value,index)=&gt;&#123; console.log(value); let newGoods = new Goods(value); newGoods.save().then(()=&gt;&#123; saveCount++; console.log(&apos;成功&apos; + saveCount) &#125;).catch(error =&gt; &#123; console.log(&apos;失败：&apos; + error) &#125;) &#125;) &#125;) ctx.body = &quot;开始导入数据!&quot;&#125;)module.exports = router; 3. 把路由加入到 index.js 里 写好了 goods.js 的路由方法，就可以把它暴露到 index.js 里了 1234// /service/index.jslet goods = require(&apos;./appApi/goods.js&apos;);router.use(&apos;/goods&apos;,goods.routes()) 做完这一步，就可以在浏览器运行一下 http://localhost:3000/goods/insertAllGoodsInfo，运行结束后，可以到数据库看一下插入情况批量插入商品详情数据到 MongoDB 中 有了可插入的 JSON 数据，就可以建立一个 Schema 模型， 然后是用 Mongoose 插入到我们的数据库中。 1. 建立 Goods 的 Schema 建立 service/database/schema/Goods.js 文件，然后根据我们的数据表结构建立模型。代码如下： 123456789101112131415161718192021222324252627282930313233343536const mongoose = require(&apos;mongoose&apos;) // 引入 Mongooseconst Schema = mongoose.Schema // 声明 Schemalet ObjectId = Schema.Types.ObjectId // 声明 Object 类型const goodsSchema = new Schema(&#123; ID:&#123;unique:true,type:String&#125;, GOODS_SERIAL_NUMBER:String, SHOP_ID:String, SUB_ID:String, GOOD_TYPE:Number, STATE:Number, NAME:String, ORI_PRICE:Number, PRESENT_PRICE:Number, AMOUNT:Number, DETAIL:String, BRIEF:String, SALES_COUNT:Number, IMAGE1:String, IMAGE2:String, IMAGE3:String, IMAGE4:String, IMAGE5:String, ORIGIN_PLACE:String, GOOD_SCENT:String, CREATE_TIME:String, UPDATE_TIME:String, IS_RECOMMEND:Number, PICTURE_COMPERSS_PATH:String&#125;,&#123; collections:&apos;Goods&apos;&#125;)mongoose.model(&apos;Goods&apos;,goodsSchema)// 这里需要注意的是，要安装我们 JSON 中的数据进行建立。 2. 批量插入数据库的路由方法 新建一个 service/appApi/goods.js 以后关于商品的操作就都在这个 api 文件中编写了，我们也是要写路由的形式，提供每一个支持。 12345678910111213141516171819202122232425262728const Koa = require(&apos;koa&apos;);const app = new Koa();const Router = require(&apos;koa-router&apos;);let router = new Router();const mongoose = require(&apos;mongoose&apos;);const fs = require(&apos;fs&apos;);router.get(&apos;/insertAllGoodsInfo&apos;,async(ctx)=&gt;&#123; fs.readFile(&apos;./goods.json&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123; data = JSON.parse(data); let saveCount = 0; const Goods = mongoose.model(&apos;Goods&apos;); data.map((value,index)=&gt;&#123; console.log(value); let newGoods = new Goods(value); newGoods.save().then(()=&gt;&#123; saveCount++; console.log(&apos;成功&apos; + saveCount) &#125;).catch(error =&gt; &#123; console.log(&apos;失败：&apos; + error) &#125;) &#125;) &#125;) ctx.body = &quot;开始导入数据!&quot;&#125;)module.exports = router; 3. 把路由加入到 index.js 里 写好了 goods.js 的路由方法，就可以把它暴露到 index.js 里了 1234// /service/index.jslet goods = require(&apos;./appApi/goods.js&apos;);router.use(&apos;/goods&apos;,goods.routes()) 做完这一步，就可以在浏览器运行一下 http://localhost:3000/goods/insertAllGoodsInfo，运行结束后，可以到数据库看一下插入情况 商品大类的 Shema 建立和导入数据库这节主要是把商品大类的数据从 JSON 格式导入到 MongoDB 数据库中，涉及到的知识点有 Schema 的建立， fs 模块的使用和 Mongoose 的存储。 1. 编写 Category 的 Schema 可以把 Schema 想象成数据库 collections 的一个复制映射，它是和数据库里的 collection 对应的。明白了这个，我们直接根据 JSON 的格式直接制作就好了 123456789101112131415// /service/database/schema/Category.jsconst mongoose = require(&apos;mongoose&apos;) //引入Mongooseconst Schema = mongoose.Schema //声明Schemaconst categorySchema = new Schema(&#123; ID:&#123;unique:true,type:String&#125;, MALL_CATEGORY_NAME:&#123;type:String&#125;, IMAGE:&#123;type:String&#125;, TYPE:&#123;type:Number&#125;, SORT:&#123;type:Number&#125;, COMMENTS:&#123;type:String&#125;&#125;)mongoose.model(&apos;Category&apos;,categorySchema) 插入 MongoDB 数据库 有了 Schema 之后可以在 service/appApi/goods.js 文件里增加一个路由配置，并把业务逻辑代码写入到路由里。 用 fs 读取 category.json 的数据 把数据进行循环存入数据库 123456789101112131415161718router.get(&apos;/insertAllCategory&apos;,async(ctx)=&gt;&#123; fs.readFile(&apos;./data_json/category.json&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123; data=JSON.parse(data) let saveCount=0 const Category = mongoose.model(&apos;Category&apos;) data.RECORDS.map((value,index)=&gt;&#123; console.log(value) let newCategory = new Category(value) newCategory.save().then(()=&gt;&#123; saveCount++ console.log(&apos;成功&apos;+saveCount) &#125;).catch(error=&gt;&#123; console.log(&apos;失败：&apos;+error) &#125;) &#125;) &#125;) ctx.body=&quot;开始导入数据&quot;&#125;) 完成后可以打开 mongod 服务， 然后访问 http://localhost:3000/goods/insertAllCategory，数据就可以顺利插入到数据库离了。子数据的操作也是差不多一样的。 商品子类的 Shema 建立和导入数据库1. categorySub 的 Schema 建立 1234567891011121314// service/database/schema/const mongoose = require(&apos;mongoose&apos;) // 引入 Mongooseconst Schema = mongoose.Schema // 声明 Schemaconst categorySubSchema = new Schema(&#123; ID:&#123;unique:true,type:String&#125;, MALL_CATEGORY_ID:&#123;type:String&#125;, MALL_SUB_NAME:&#123;type:String&#125;, COMMENTS:&#123;type:String&#125;, SORT:&#123;type:Number&#125;&#125;)mongoose.model(&apos;CategorySub&apos;,categorySubSchema) 2. 保存到数据库的业务逻辑 1234567891011121314151617181920// service/appApi/goods.jsrouter.get(&apos;/insertAllCategorySub&apos;,async(ctx)=&gt;&#123; fs.readFile(&apos;./data_json/category_sub.json&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123; data = JSON.parse(data); let saveCount = 0; const CategorySub = mongoose.model(&apos;CategorySub&apos;); data.RECORDS.map((value,index)=&gt;&#123; console.log(value); let newCategorySub = new CategorySub(value) newCategorySub.save().then(()=&gt;&#123; saveCount++; console.log(&apos;成功插入&apos;+saveCount) &#125;).catch(error=&gt;&#123; console.log(&apos;插入失败&apos;+error) &#125;) &#125;) &#125;) ctx.body = &quot;开始导入数据&quot;&#125;) 编写商品详情页的数据接口1. 编写后台数据接口 在 service/appApi/goods.js 里，新编写一个路由业务逻辑，并用 findOne 的形式查找出一条商品数据。代码如下： 12345678910111213/* 获取商品详细信息的接口 */router.post(&apos;/getDetailGoodsInfo&apos;,async(ctx)=&gt;&#123; let goodsId = ctx.request.body.goodsId; const Goods = mongoose.model(&apos;Goods&apos;); await Goods.findOne(&#123;ID:goodsId&#125;).exec() .then(async(result) =&gt; &#123; ctx.body = &#123;code:200,message:result&#125; &#125;) .catch(error =&gt; &#123; console.log(error); ctx.body = &#123;code:500,message:error&#125; &#125;)&#125;) 首先获得了从前端得到的参数 goodsId， 然后得到 Goods 模型， 用模型的 findOne 方法查找数据，查找出来进行返回。 2. 编写 Goods.vue 页面 由于现在还不能正常查看接口，所以我们需要一个页面，来调用接口。 新建 /src/components/pages/Goods.vue 文件。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; 商品详情页面 &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import axios from &apos;axios&apos; import url from &apos;@/serviceAPI.config.js&apos; export default &#123; data() &#123; return &#123; goodsId: &apos;775e575ce28a4f89b1dfe2c99eb08ae7&apos; &#125; &#125;, created()&#123; this.getInfo() &#125;, methods: &#123; getInfo() &#123; axios(&#123; url:url.getDetailGoodsInfo, method:&apos;post&apos;, data:&#123; goodsId:this.goodsId &#125; &#125;) .then(response=&gt;&#123; console.log(response) &#125;) .catch(error=&gt;&#123; console.log(error) &#125;) &#125; &#125;, &#125;&lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 3. 把组件加入到路由管理器中 有了模块之后，我们需要把模块加入到路由管理之中，这样才可以正常访问。 1234567891011121314151617import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import ShoppingMall from &apos;@/components/pages/ShoppingMall&apos;import Login from &apos;@/components/pages/Login&apos;import Register from &apos;@/components/pages/Register&apos;import Goods from &apos;@/components/pages/Goods&apos; Vue.use(Router) export default new Router(&#123; routes: [ &#123;path: &apos;/&apos;,name: &apos;ShoppingMall&apos;,component: ShoppingMall&#125;, &#123;path: &apos;/register&apos;,name: &apos;Register&apos;,component: Register&#125;, &#123;path: &apos;/login&apos;,name: &apos;Login&apos;,component: Login&#125;, &#123;path: &apos;/Goods&apos;,name: &apos;Goods&apos;,component: Goods&#125;, ]&#125;) 现在可以直接打开 http://localhost:8080/#/Goods 路径，然后打开控制台，可以发现已经顺利的从后台取得数据了。 改写程序，让程序更优雅 1234567891011// 把上面的代码进行改写，改成只用 async/await 的方式router.post(&apos;/getDetailGoodsInfo&apos;,async(ctx) =&gt; &#123; try&#123; let goodsId = ctx.request.body.goodsId; const Goods = mongoose.model(&apos;Goods&apos;); let result = await Goods.findOne(&#123;ID: goodsId&#125;).exec(); ctx.body = &#123;code:200,message:result&#125; &#125; catch(err) &#123; ctx.body = &#123;code:500,message:err&#125; &#125;&#125;) 商品详情页路由的制作和参数的传递修改 goodsInfoComponent.vue 文件 修改这个文件主要是让它具有跳转能力和传递参数的能力： 在这个组件里新加入一个 props，接受 goodsId 编写一个页面跳转的方法，这里起名为 goGoodsPage 绑定单击事件进行跳转 @click=’goGoodsPage’ 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;goods-info&quot; @click=&quot;goGoodsPage()&quot;&gt; &lt;div class=&quot;goods-image&quot;&gt; &lt;img v-lazy=&quot;goodsImage&quot; width=&quot;90%&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;goods-name&quot;&gt;&#123;&#123;goodsName&#125;&#125;&lt;/div&gt; &lt;div class=&quot;goods-price&quot;&gt;￥&#123;&#123;goodsPrice | moneyFilter &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import &#123;toMoney&#125; from &apos;@/filter/moneyFilter.js&apos; export default &#123; props:[&apos;goodsImage&apos;,&apos;goodsName&apos;,&apos;goodsPrice&apos;,&apos;goodsId&apos;], filters:&#123; moneyFilter(money)&#123; return toMoney(money) &#125; &#125;, methods: &#123; goGoodsPage() &#123; this.$router.push(&#123;name:&apos;Goods&apos;,query:&#123;goodsId:this.goodsId&#125;&#125;) &#125; &#125;, &#125;&lt;/script&gt; &lt;style scoped&gt; .goods-name&#123; padding: 0 8px; overflow: hidden; text-overflow: ellipsis; white-space:nowrap; &#125;&lt;/style&gt; 接收路由传递的参数 接收参数可以使用 this.$route.query.goodsId，这样就可以得到由其他页面传递过来的参数了。 在 src/components/pages/Goods.vue 的 created 生命周期里修改如下： 12345created()&#123; this.goodsId = this.$route.query.goodsId; console.log(this.goodsId); this.getInfo();&#125;, 改写首页，传递 goodsId 参数 在 src/components/pages/ShoppingMall.vue 里，热卖商品的属性部分绑定 goodsId- :goodsID=’item.goodsId’ 代码如下： 12345678910111213&lt;!--Hot Area--&gt;&lt;div class=&quot;hot-area&quot;&gt; &lt;div class=&quot;hot-title&quot;&gt;热卖商品&lt;/div&gt; &lt;div class=&quot;hot-goods&quot;&gt; &lt;van-list&gt; &lt;van-row gutter=&quot;20&quot;&gt; &lt;van-col span=&quot;12&quot; v-for=&quot;(item,index) in hotGoods&quot; :key=&quot;index&quot;&gt; &lt;goods-info :goodsId=&quot;item.goodsId&quot; :goodsImage=&quot;item.image&quot; :goodsName=&quot;item.name&quot; :goodsPrice=&quot;item.price&quot;&gt;&lt;/goods-info&gt; &lt;/van-col&gt; &lt;/van-row&gt; &lt;/van-list&gt; &lt;/div&gt;&lt;/div&gt; 商品详情的页面模板编写11. 引入 Vant 框架中的 NavBar 组件 在项目的 /src/main.js 文件中用 import 引入 NavBar 组件 import { NavBar } from ‘vant’ Vue.use(NavNar) 2. 使用 NavBar 制作头部导航 打开 /src/components/pages/Goods.vue 文件，编写 template 部分代码，直接使用 van-nav-bar 组件 12345678910&lt;div&gt; &lt;div class=&quot;navbar-div&quot;&gt; &lt;van-nav-bar title=&quot;商品详情&quot; left-text=&quot;返回&quot; left-arrow @click-left=&quot;onClickLeft&quot; /&gt; &lt;/div&gt;&lt;/div&gt; title： 是显示的标题，这里就起名字叫做商品详情 left-text： 是左侧显示的内容，治理显示 “返回” 两个字 left-arrow：是否显示左侧箭头，默认值是 true，也就是显示 @click-left：绑定左侧按钮时触发的事件方法，方法名字叫做 onClickLeft 编写 onClickLeft 方法，这个方法里边现在只要能回退到上一层路由就可以了，暂时不写其他逻辑，以后使用了页面缓存功能后，还要增加消除缓存的操作。 123onClickLeft()&#123; this.$router.go(-1);&#125;, 打开浏览器，测试一下是否点击返回按钮可以实现返回上一级路由 3. 编写商品图片部分 直接使用 html 中的 img 标签把头图显示出来 123&lt;div class=&quot;topimage-div&quot;&gt; &lt;img :src=&quot;goodsInfo.IMAGE1&quot; width=&quot;100%&quot;&gt;&lt;/div&gt; 这里还没有 goodsInfo 注册数据，所以还需要在 js 部分的 data 中先进行注册 123456data() &#123; return &#123; goodsId: &apos;&apos;, goodsInfo: &#123;&#125;, // 商品详细数据 &#125;&#125; 然后在 getInfo 方法里， 对 goodsInfo 进行赋值：this.goodsInfo = response.data.message 直接这样写不够严谨，应该在赋值前判断一下 code 的值和 message 不为空，代码如下： 123456if(response.data.code == 200 &amp;&amp; response.data.message )&#123; this.goodsInfo = response.data.message &#125;else&#123; Toast(&apos;服务器错误，数据取得失败&apos;)&#125;console.log( this.goodsInfo ) 商品详情的页面模板编写2修改商品详情页面的布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt;&lt;div&gt; &lt;div class=&quot;navbar-div&quot;&gt; &lt;van-nav-bar title=&quot;商品详情&quot; left-text=&quot;返回&quot; left-arrow @click-left=&quot;onClickLeft&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;topimage-div&quot;&gt; &lt;img :src=&quot;goodsInfo.IMAGE1&quot; width=&quot;100%&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;goods-name&quot;&gt;&#123;&#123;goodsInfo.NAME&#125;&#125;&lt;/div&gt; &lt;div class=&quot;goods-price&quot;&gt;价格：&#123;&#123;goodsInfo.PRESENT_PRICE&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;van-tabs &gt; &lt;van-tab title=&quot;商品详情&quot;&gt; &lt;div class=&quot;detail&quot; v-html=&quot;goodsInfo.DETAIL&quot;&gt; &lt;/div&gt; &lt;/van-tab&gt; &lt;van-tab title=&quot;评价&quot;&gt; 正在制作中 &lt;/van-tab&gt; &lt;/van-tabs&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt; &lt;script&gt; import axios from &apos;axios&apos; import url from &apos;@/serviceAPI.config.js&apos; import &#123; Toast &#125; from &apos;vant&apos; export default &#123; data() &#123; return &#123; goodsId: &apos;&apos;, goodsInfo:&#123;&#125;, //商品详细数据 &#125; &#125;, created()&#123; this.goodsId= this.$route.query.goodsId console.log(this.goodsId) this.getInfo() &#125;, methods: &#123; onClickLeft()&#123; this.$router.go(-1) &#125;, getInfo() &#123; axios(&#123; url:url.getDetailGoodsInfo, method:&apos;post&apos;, data:&#123; goodsId:this.goodsId &#125; &#125;) .then(response=&gt;&#123; if(response.data.code == 200 &amp;&amp; response.data.message )&#123; this.goodsInfo = response.data.message &#125;else&#123; Toast(&apos;服务器错误，数据取得失败&apos;) &#125; console.log( this.goodsInfo) &#125;) .catch(error=&gt;&#123; console.log(error) &#125;) &#125; &#125;, &#125;&lt;/script&gt; &lt;style scoped&gt; .detail&#123; font-size:0px; &#125; .goods-name&#123; background-color: #fff; &#125; .goods-price&#123; background-color: #fff; &#125;&lt;/style&gt; vant 标签组件的使用 首先引入标签组件，在 main.js 里直接引入。 代码如下： 123456import &#123; Tab,Tabs &#125; from &apos;vant&apos;Vue.use(Field).use(Tab).use(Tabs)// 引入之后就可以在商品组件中直接使用了 编写 template 代码 123456789&lt;van-tabs &gt;&lt;van-tab title=&quot;商品详情&quot;&gt; &lt;div class=&quot;detail&quot; v-html=&quot;goodsInfo.DETAIL&quot;&gt; &lt;/div&gt;&lt;/van-tab&gt;&lt;van-tab title=&quot;评价&quot;&gt; 正在制作中&lt;/van-tab&gt;&lt;/van-tabs&gt; 解决图片有空隙问题 因为每个图片后面是有空格的，而图片占了宽度的 100%，所以空格被单独挤出了一行。 解决方法： 把字体设置为 0，但是这样做如果以后有图文混排就会出现不显示字体的 BUG。所以最好的就决方案是后端插入的时候就取消掉空格。 123.detail &#123; font-size: 0px;&#125; 商品详情的页面模板编写3加入价格的过滤器和底部的加入购物车和购买按钮 加入 Filter 过滤器来格式化价格 页面中的价格并没有进行格式化，需要一个 Filter 来进行格式化，在制作首页的时候，已经制作了一个 Filter，直接使用就可以进行格式化了。 引入 moneyFilter.js 文件 1import &#123; toMoney &#125; from &apos;@/filter/moneyFilter.js&apos; 在 js 部分编写 filters 属性 12345filters: &#123; moneyFilter( money )&#123; return toMoney( money ) &#125;&#125;, 给价格加上 Filter 1&#123;&#123; goodsInfo.PRESENT_PRICE | moneyFilter &#125;&#125; 通过上面的三步，就可以实现价格的格式化了。 底部购买按钮和加入购物车按钮 在 template 的最底部，加入一个层，并进行基本的 flex 布局 12345678&lt;div class=&quot;goods-bottom&quot;&gt; &lt;div&gt; &lt;van-button size=&quot;large&quot; type=&quot;primary&quot;&gt;加入购物车&lt;/van-button&gt; &lt;/div&gt; &lt;div&gt; &lt;van-button size=&quot;large&quot; type=&quot;danger&quot;&gt;直接购买&lt;/van-button&gt; &lt;/div&gt;&lt;/div&gt; 编写 CSS 样式： 123456789101112131415.goods-bottom&#123; position: fixed; bottom:0px; left:0px; background-color: #FFF; width:100%; display: flex; flex-direction: row; flex-flow: nowrap;&#125;.goods-bottom &amp;gt; div&#123; flex:1; padding:5px;&#125; 分类页面的数据读取读取大类别的 API 制作 首先获取大类信息，在 /service/appApi/goods.js 里增加一个新的路由 getCategoryList 代码如下： 123456789router.get(&apos;/getCategoryList&apos;,async(ctx) =&gt; &#123; try&#123; const Category = mongoose.model(&apos;Category&apos;); let result = await Category.find().exec(); ctx.body = &#123;code:200, message:result&#125;; &#125; catch (err) &#123; ctx.body = &#123;code: 500, message: err&#125; &#125;&#125;) 打开浏览器进行测试 http://localhost:3000/goods/getCategoryList 读取小类别的 API 制作 在 /service/appApi/goods.js 里增加一个新的路由 getCategorySubList 代码如下： 1234567891011router.get(&apos;/getCategorySubList&apos;,async(ctx) =&gt; &#123; try&#123; // let categoryId = ctx.request.body.categoryId let categoryId = 1; const CategorySub = mongoose.model(&apos;CategorySub&apos;); let result = await CategorySub.find(&#123;MALL_CATEGORY_ID:categoryId&#125;).exec(); ctx.body = &#123;code:200, message:result&#125; &#125; catch(err) &#123; ctx.body = &#123;code:500, message:err&#125; &#125;&#125;) 打开浏览器进行测试， http://localhost:3000/goods/getCategorySubList 根据商品类别获取商品列表 在 /service/appApi/goods.js 里新增加一个新的路由 getGoodsListByCategorySubID 代码如下： 1234567891011router.get(&apos;/getGoodsListByCategorySubID&apos;,async(ctx) =&gt; &#123; try&#123; // let categorySubId = ctx.request.body.categoryId let categorySubId = &apos;2c9f6c946016ea9b016016f79c8e0000&apos;; const Goods = mongoose.model(&apos;Goods&apos;); let result = await Goods.find(&#123;SUB_ID:categorySubId&#125;).exec(); ctx.body = &#123;code:200, message: result&#125;; &#125; catch(err) &#123; ctx.body = &#123;code:500, message:err&#125; &#125;&#125;) 打开浏览器进行测试 http://localhost:3000/goods/getGoodsListByCategorySubID 商品详细页的滑动切换和吸顶效果Tab 页的滑动切换 通过 van-tabs 里的 swipeable 属性就可以开启滑动切换 tab 页的效果，代码如下： 12345678&lt;van-tabs swipeable&gt; &lt;van-tab title=&quot;商品详情&quot;&gt; &lt;div class=&quot;detail&quot; v-html=&quot;goodsInfo.DETAIL&quot;&gt;&lt;/div&gt; &lt;/van-tab&gt; &lt;van-tab title=&quot;评价&quot;&gt; 正在制作中 &lt;/van-tab&gt;&lt;/van-tabs&gt; 吸顶效果的制作 通过 van-tabs 里的 sticky 属性可以开启吸顶效果，也叫粘性布局，当 Tab 滚动到顶部时会自动吸顶。 12345678&lt;van-tabs swipeable sticky&gt; &lt;van-tab title=&quot;商品详情&quot;&gt; &lt;div class=&quot;detail&quot; v-html=&quot;goodsInfo.DETAIL&quot;&gt;&lt;/div&gt; &lt;/van-tab&gt; &lt;van-tab title=&quot;评价&quot;&gt; 正在制作中 &lt;/van-tab&gt;&lt;/van-tabs&gt; 商品列表页的布局1建立页面和配置列表页路由 在 /src/components/pages 文件夹下新建一个 CategoryList.vue 页面。 然后利用 vbase 命令快速建立基本结构。 有了基本的页面后，到 /src/router/index.js 文件里， 添加 CategoryList.vue 页面的路由 12345678910111213141516171819import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import ShoppingMall from &apos;@/components/pages/ShoppingMall&apos;import Login from &apos;@/components/pages/Login&apos;import Register from &apos;@/components/pages/Register&apos;import Goods from &apos;@/components/pages/Goods&apos;import CategoryList from &apos;@/components/pages/CategoryList&apos; Vue.use(Router) export default new Router(&#123; routes: [ &#123;path: &apos;/&apos;,name: &apos;ShoppingMall&apos;,component: ShoppingMall&#125;, &#123;path: &apos;/register&apos;,name: &apos;Register&apos;,component: Register&#125;, &#123;path: &apos;/login&apos;,name: &apos;Login&apos;,component: Login&#125;, &#123;path: &apos;/Goods&apos;,name: &apos;Goods&apos;,component: Goods&#125;, &#123;path: &apos;/CategoryList&apos;,name: &apos;CategoryList&apos;,component: CategoryList&#125;, ]&#125;) 做完这步，我们的页面就可以正常访问到了，访问地址 http://localhost:8080/#/CategoryList 标题栏的布局 使用 Vant 提供好的 van-nav-bar 组件为页面添加一个标题 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;div class=&quot;navbar-div&quot;&gt; &lt;van-nav-bar title=&quot;类别列表&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; &#125;&lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 如果希望它固定在头部， 可以加入 fixed 属性。 大类的侧边栏的布局 使用 row-col 进行布局，代码如下： 12345678910&lt;div&gt; &lt;van-row&gt; &lt;van-col span=&quot;6&quot;&gt; &lt;div id=&quot;leftNav&quot;&gt; 左侧导航 &lt;/div&gt; &lt;/van-col&gt; &lt;van-col span=&quot;18&quot;&gt;右侧列表&lt;/van-col&gt; &lt;/van-row&gt;&lt;/div&gt; axios 读取左侧大类 用 import 先导入 axios 和 serviceAPI.config.js，代码如下： import axios from ‘axios’ import url from ‘@/serviceAPI.config.js’ 配置 serviceAPI.config.js 文件 12345678910111213const BASEURL = &quot;https://www.easy-mock.com/mock/5ae2eeb23fbbf24d8cd7f0b6/SmileVue/&quot;const LOCALURL = &quot;http://localhost:3000/&quot;const URL = &#123; getShoppingMallInfo:BASEURL+&apos;index&apos;, getGoodsInfo:BASEURL+&apos;getGoodsInfo&apos;, registerUser:LOCALURL+&apos;user/register&apos;, //用户注册接口 login:LOCALURL+&apos;user/login&apos;, //用户注册接口 getDetailGoodsInfo:LOCALURL+&apos;goods/getDetailGoodsInfo&apos;, //得到商品详细数据 getCategoryList:LOCALURL+&apos;goods/getCategoryList&apos;, //得到大类信息 &#125; module.exports = URL 编写 axios 方法 1234567891011121314151617181920getCategory() &#123; axios(&#123; url:url.getCategoryList, method:&apos;get&apos;, &#125;) .then(response=&gt;&#123; console.log(response) if(response.data.code == 200 &amp;&amp; response.data.message )&#123; &#125;else&#123; Toast(&apos;服务器错误，数据取得失败&apos;) &#125; &#125;) .catch(error=&gt;&#123; console.log(error) &#125;) &#125; 在生命周期里加入 getCategory 方法 123created()&#123; this.getCategory();&#125;, 商品列表页的大类交互效果把大类列表放到左侧导航上 在 data 属性里注册 category 变量为数组类型 12345data() &#123; return &#123; category: [], &#125;&#125;, 在 getCategory() 方法里的 axios 的回调方法里为 category 赋值 1234567891011121314151617getCategory() &#123; axios(&#123; url: url.getCategoryList, method: &apos;get&apos;, &#125;) .then(response =&gt; &#123; console.log(response) if (response.data.code == 200 &amp;&amp; response.data.message )&#123; this.category = response.data.message &#125; else &#123; Toast(&apos;服务器错误，数据获取失败&apos;) &#125; &#125;) .catch(error =&gt; &#123; console.log(error); &#125;)&#125; 在 template 部分利用 li 标签把数据循环出来 1234567&lt;div id=&quot;leftNav&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in category&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.MALL_CATEGORY_NAME&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 编写 CSS 样式 12345678910#leftNav&#123; background-color: aliceblue;&#125;#leftNav ul li &#123; line-height: 2rem; border-bottom:1px solid #E4E7ED; padding:3px; font-size:0.8rem; text-align: center;&#125; 在生命周期里加入 js，让左侧适应页面高度 1234mounted()&#123; let winHeight = document.documentElement.clientHeight; document.getElementById(&quot;leftNav&quot;).style.height = winHeight - 46 + &quot;px&quot;;&#125;, 点击后的交互效果制作 — 反白操作 当点击每个大类的时候，我们希望 CSS 是有所变化的，证明我们已经点击过了，前端也叫做反白操作。 编写一个背景为白色的 CSS 样式 123.categoryActive&#123; background-color: #fff;&#125; 在 data 里注册一个 categoryIndex 变量，用来控制那个导航变成白色，这里默认是 0，就是当打开页面时第一个类别是白色的 123456data() &#123; return &#123; category:[], categoryIndex:0, &#125;&#125;, 编写 clickCategory 方法，点击大类时调用这个方法，方法就是把点击的索引传递过去，然后付给刚才注册的 categoryIndex 属性 1234//点击大类的方法clickCategory(index)&#123; this.categoryIndex=index&#125; 在 template 里注册这些方法，并进行 class 动态绑定， 代码如下： 123&lt;li @click=&quot;clickCategory(index)&quot; :class=&quot;&#123;categoryActive:categoryIndex==index&#125;&quot; v-for=&quot;(item,index) in category&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.MALL_CATEGORY_NAME&#125;&#125;&lt;/li&gt; 一二级分类的联动效果制作当点击一级分类的时候，二级分类要根据你点击的一级分类进行变化。可以直接使用 Vant 的 Tab 组件来实现。 在 serviceAPI.config.js 中加入接口 直接把 service 中写的 API 方法，加入到前端接口配置文件中， getCategorySubList:LOCALURL+&#39;goods/getCategorySubList&#39;,,全部代码如下： 1234567891011121314const BASEURL = &quot;https://www.easy-mock.com/mock/5ae2eeb23fbbf24d8cd7f0b6/SmileVue/&quot;const LOCALURL = &quot;http://localhost:3000/&quot;const URL = &#123; getShoppingMallInfo:BASEURL+&apos;index&apos;, getGoodsInfo:BASEURL+&apos;getGoodsInfo&apos;, registerUser:LOCALURL+&apos;user/register&apos;, //用户注册接口 login:LOCALURL+&apos;user/login&apos;, //用户注册接口 getDetailGoodsInfo:LOCALURL+&apos;goods/getDetailGoodsInfo&apos;, //得到商品详细数据 getCategoryList:LOCALURL+&apos;goods/getCategoryList&apos;, //得到大类信息 getCategorySubList:LOCALURL+&apos;goods/getCategorySubList&apos;, //得到小类信息 &#125; module.exports = URL 改写后端接口 以前写后端接口时，为了测试，所以使用的是 get 方法，但是为了传送数据的安全和方便，现在改为 post 方法，并接受前端传递过来的 categoryId 参数。 代码如下： 123456789101112// service/appApi/goods.jsrouter.post(&apos;/getCategorySubList&apos;,async(ctx)=&gt;&#123; try&#123; let categoryId = ctx.request.body.categoryId const CategorySub = mongoose.model(&apos;CategorySub&apos;) let result = await CategorySub.find(&#123;MALL_CATEGORY_ID:categoryId&#125;).exec() ctx.body=&#123;code:200,message:result&#125; &#125;catch(err)&#123; ctx.body=&#123;code:500,message:err&#125; &#125;&#125;) 获取小类的方法 在 CategoryList 文件的 methods 属性里， 加入一个 getCategorySubByCategoryId 方法。 这里主要使用 axios 来获取后端的数据。 1234567891011121314151617181920//根据大类ID读取小类类别列表getCategorySubByCategoryId(categoryId)&#123; axios(&#123; url:url.getCategorySubList, method:&apos;post&apos;, data:&#123;categoryId:categoryId&#125; &#125;) .then(response=&gt;&#123; if(response.data.code == 200 &amp;&amp; response.data.message )&#123; this.categorySub=response.data.message this.active = 0 &#125;else&#123; Toast(&apos;服务器错误，数据取得失败&apos;) &#125; &#125;) .catch(error=&gt;&#123; console.log(error) &#125;) &#125; 改写 clickCategory 方法，加入一个 categoryId 参数，然后在方法里调用刚才写的 getCategorySubByCategoryId 方法，这样就可以实现二级联动效果了。 123456//点击大类的方法clickCategory(index,categoryId)&#123; this.categoryIndex=index this.getCategorySubByCategoryId(categoryId) &#125;, 用 Vant 的 Tabs 组件实现联动 这里直接使用 Vant 提供的 Tabs 组件来实现联动， 代码如下： 1234567&lt;div class=&quot;tabCategorySub&quot;&gt; &lt;van-tabs v-model=&quot;active&quot;&gt; &lt;van-tab v-for=&quot;(item, index) in categorySub&quot; :key=&quot;index&quot; :title=&quot;item.MALL_SUB_NAME&quot;&gt; &lt;/van-tab&gt; &lt;/van-tabs&gt;&lt;/div&gt; 现在可以在浏览器中看一下效果了，但是还是有些小 Bug，就是在进入页面的时候是没有二级分类的。这个只要在 getCategory 方法的回调函数里调用一下 getCategorySubByCategoryId 方法就可以了 this.getCategorySubByCategoryId( this.category[0].ID ) 这里的 this.category[0].ID 是通过数组索引取得默认的第一个分类的 ID 值 商品列表上拉加载效果的实现在列表页中都是需要两个基本的功能需求： 上拉加载和下拉刷新。可以使用 Vant 的 List 组件来实现上拉加载效果。 实现上拉加载效果 首先引入，在 src/main.js 中加入引入代码： import { List } from ‘vant’ Vue.use( List ) 在 data 里声明两个属性： loading 和 finished 1234567891011data()&#123; return &#123; category: [], categoryIndex: 0, active: 0, categorySub: [], list: [], loading: false, // 上拉加载使用 finished: false, // 下拉加载是否没有数据了 &#125;&#125;， 在 methods 属性中编写 onLoad() 方法，用于实现上拉加载 1234567891011onLoad()&#123; setTimeout(()=&gt;&#123; for(let i = 0; i &lt; 10; i++) &#123; this.list.push(this.list.length+1); &#125; this.loading = false; if ( this.list.length &gt;= 40 ) &#123; this.finished = true; &#125; &#125;,500);&#125; 在模板中加入组件代码， 代码如下 1234567891011&lt;div id=&quot;list-div&quot;&gt; &lt;van-list v-model=&quot;loading&quot; :finished=&quot;finished&quot; @load=&quot;onLoad&quot; &gt; &lt;div class=&quot;list-item&quot; v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;/van-list&gt;&lt;/div&gt; 预览效果，根据效果编写 CSS 样式。 123456789.list-item&#123; text-align: center; line-height: 80px; border-bottom: 1px solid #f0f0f0; background-color: #fff; &#125; #list-div&#123; overflow: scroll; &#125; 在 mounted() 生命周期里设置 list-dev 的高度 12345mounted()&#123; let winHeight = document.documentElement.clientHeight; document.getElementById(&apos;leftNav&apos;).style.height = winHeight - 46 + &apos;px&apos;; document.getElementById(&apos;list-div&apos;).style.height = winHeight - 90 + &apos;px&apos;;&#125;, 商品列表页下拉刷新效果的实现列表页的下拉刷新， 并不是指刷新整个页面。 引入 Vant 中的 PullRefresh 组件 引入 pullRefresh 组件就可以实现下拉刷新效果，先在 src/main.js 中引入一下。 import { PullRefresh } from ‘vant’ Vue.use(PullRefresh) 增加下拉刷新用的变量和方法 在 data 中增加一个 isRefresh 属性，用来说明现在的状态是否是下拉加载状态。 123456789101112data()&#123; return &#123; category: [], categoryIndex: 0, active: 0, categorySub: [], list: [], loading: false, // 上拉加载使用 finished: false, // 上拉加载是否没有了 isRefresh: false, // 下拉加载 &#125;&#125; 然后写一个 onRefresh 方法，用来重新加载数据 1234567onRefresh()&#123; setTimeout( ()=&gt;&#123; this.isRefresh = false; this.list = []; this.onLoad(); &#125;, 500);&#125; 先把 list 数组清空，然后再次调用 onLoad() 方法，这样就会刷新商品列表页面了 编写 template 部分 直接在 van-list 组件外边加入 van-pull-refresh 组件就可以实现了，具体代码如下： 12345678910111213&lt;div id=&quot;list-div&quot;&gt; &lt;van-pull-refresh v-model=&quot;isRefresh&quot; @refresh=&quot;onRefresh&quot;&gt; &lt;van-list v-model=&quot;loading&quot; :finished=&quot;finished&quot; @load=&quot;onLoad&quot; &gt; &lt;div class=&quot;list-item&quot; v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;/van-list&gt; &lt;/van-pull-refresh&gt;&lt;/div&gt; 商品类别分类的 Koa2 分页服务制作修改 Koa2 服务代码 进入 service/appApi/goods.js 找到 getGoodsListByCategorySubID 这个请求进行改造 123456789101112131415router.post(&apos;/getGoodsListByCategorySubID&apos;,async(ctx)=&gt;&#123; try&#123; let categorySubId = ctx.request.body.categorySubId //小类别 let page =ctx.request.body.page let num = 10 //每页显示数量 let start = (page-1)*num //let categorySubId = &apos;2c9f6c946016ea9b016016f79c8e0000&apos; const Goods = mongoose.model(&apos;Goods&apos;) let result = await Goods.find(&#123;SUB_ID:categorySubId&#125;) .skip(start) .limit(num).exec() ctx.body=&#123;code:200,message:result&#125; &#125;catch(err)&#123; ctx.body=&#123;code:500,message:err&#125; &#125;&#125;) 首先把请求方式改为了 post，然后从前台接收两个数据 categorySubId ( 子类ID号 ) 和 page ( 当前页数 )。定义每页显示的数量，然后再根据每页数量和当前页数算出开始读取的位置 start 。有了开始位置和每页显示数量，就尅顺利得出我们想要的结果了。 把写好的接口加入到前台 打开 src/serviceAPI.config.js 文件，在最后加入代码： getGoodsListByCategorySubID:LOCALURL+’goods/getGoodsListByCategorySubID’, //得到小类商品信息 此时全部代码如下： 1234567891011121314const BASEURL = &quot;https://www.easy-mock.com/mock/5ae2eeb23fbbf24d8cd7f0b6/SmileVue/&quot;const LOCALURL = &quot;http://localhost:3000/&quot;const URL = &#123; getShoppingMallInfo:BASEURL+&apos;index&apos;, getGoodsInfo:BASEURL+&apos;getGoodsInfo&apos;, registerUser:LOCALURL+&apos;user/register&apos;, //用户注册接口 login:LOCALURL+&apos;user/login&apos;, //用户注册接口 getDetailGoodsInfo:LOCALURL+&apos;goods/getDetailGoodsInfo&apos;, //得到商品详细数据 getCategoryList:LOCALURL+&apos;goods/getCategoryList&apos;, //得到大类信息 getCategorySubList:LOCALURL+&apos;goods/getCategorySubList&apos;, //得到小类信息 getGoodsListByCategorySubID:LOCALURL+&apos;goods/getGoodsListByCategorySubID&apos;, //得到小类商品信息 &#125;module.exports = URL 真实数据的上拉加载效果制作在 data 属性里注册必要的参数 在 src/components/pages/CategoryList.vue 里注册几个属性，代码如下： 1234567data () &#123; return &#123; page: 1, // 商品列表的页数 goodList: [], // 商品信息 categorySubId: &apos;&apos; // 商品字分类ID &#125;&#125;， 编写 axios 商品列表的获取方法 增加 getGoodList 方法，这个方法里传递两个参数，第一个是商品的子分类，第二个是请求分类的页数。 12345678910111213141516171819202122getGoodList()&#123; axios(&#123; url: url.getGoodListByCategorySubID, method: &apos;post&apos;, data: &#123; categorySubId: this.categorySubId, page: this.page &#125; &#125;).then(response =&gt; &#123; console.log(response); if(response.data.code == 200 &amp;&amp; response.data.message.length)&#123; this.page++; this.goodList = this.goodList.concat(response.data.message) &#125; else &#123; this.finished = true; &#125; this.loading = false; console.log(this.finished); &#125;).catch(error =&gt; &#123; console.log(error); &#125;)&#125; 点击获取子类商品信息的方法 编写点击子类 Tab，就可以获取子类 ID 的方法，在获取子类 ID 的同时，需要做一些变量的初始化操作，比如把 goodsList 变量清空。 12345678910// 点击子类获取商品信息onClickCategorySub(index,title)&#123; this.categorySubId = this.categorySub[index].ID; console.log(this.categorySubId); this.goodList = []; this.finished = false; this.page = 1; this.onLoad();&#125; 改造大类的方法 在点击大类时，同样也要进行一些初始化操作 12345678// 点击大类的方法clickCategory(index,categoryId)&#123; this.categoryIndex = index; this.page = 1; this.finished = false; this.goodList = []; this.getCategorySubByCategoryId(categoryId);&#125;, 编写 OnLoad 方法，实现上拉加载效果 123456onLoad()&#123; setTimeout(()=&gt;&#123; this.categorySubId = this.categorySubId ? this.categorySubId : this.categorySub[0].ID; this.getGoodList(); &#125;,1000)&#125;, 编写 html 和 CSS 1234567891011121314151617181920212223242526272829303132333435// HTML 部分&lt;van-list v-model=&quot;loading&quot; :finished=&quot;finished&quot; @load=&quot;onLoad&quot; &gt; &lt;div class=&quot;list-item&quot; v-for=&quot;(item,index) in goodList&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;list-item-img&quot;&gt;&lt;img :src=&quot;item.IMAGE1&quot; width=&quot;100%&quot;/&gt;&lt;/div&gt; &lt;div class=&quot;list-item-text&quot;&gt; &lt;div&gt;&#123;&#123;item.NAME&#125;&#125;&lt;/div&gt; &lt;div class=&quot;&quot;&gt;￥&#123;&#123;item.ORI_PRICE&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/van-list&gt;// CSS 部分.list-item&#123; display: flex; flex-direction: row; font-size:0.8rem; border-bottom: 1px solid #f0f0f0; background-color: #fff; padding:5px; &#125; #list-div&#123; overflow: scroll; &#125; .list-item-img&#123; flex:8; &#125; .list-item-text&#123; flex:16; margin-top:10px; margin-left:10px; &#125; 真实数据的下拉刷新效果制作下拉刷新效果的制作 在 /src/components/pages/CategoryList.vue 文件中改写 onRefresh() 方法 123456789onRefresh()&#123; setTimeout(() =&gt; &#123; this.isRefresh = false; this.finished = false; this.goodList = []; this.page = 1; this.onLoad(); &#125;,500)&#125;, 解决首页类别导航图片大小不一的 BUG 先给 导航栏的层 添加一个 type-item 的 class 1234567// ShoppingMall.vue&lt;div class=&quot;type-bar&quot;&gt; &lt;div class=&quot;type-item&quot; v-for=&quot;(cate,index) in category&quot; :key=&quot;index&quot; &gt; &lt;img v-lazy=&quot;cate.image&quot; width=&quot;90%&quot; /&gt; &lt;span&gt;&#123;&#123;cate.mallCategoryName&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 然后在 CSS 部分加入一句 CSS 代码 123.type-item &#123; flex: 1;&#125; 或者不用修改 html 部分，直接只添加一行 CSS 代码也可以 123.type-bar div &#123; flex: 1;&#125; Vue 中图片失效替补图片的制作方法在获取的商品信息中，有一些商品图片已经失效，如果在真实的项目中遇到这类问题，是不允许直接显示图片失效的，所以我们需要显示一个替补图片 制作一张替补图片 使用 PS 制作一张替补图片，尽量不要使用彩色，而是使用黑白灰来制作。或者直接在网上随便找一张。 把图片放到相应位置 把图片命名为 errorimg.png, 并放到 /src/assets/images/errorimg.png. 然后在 src/components/pages/CategoryList.vue 中的 data 中加入 errorImg 属性，代码如下。 12345678910111213141516data() &#123; return &#123; category:[], categoryIndex:0, active:0, categorySub:[], list:[], loading:false, //上拉加载使用 finished:false, //上拉加载是否没有了？ isRefresh:false, //下拉加载 page:1, //商品列表的页数 goodList:[], //商品信息 categorySubId:&apos;&apos;, //商品子分类ID errorImg:&apos;this.src=&quot;&apos; + require(&apos;@/assets/images/errorimg.png&apos;) + &apos;&quot;&apos; , //错误图片显示路径 &#125;&#125;, 在图片位置加入 onerror 事件 123&lt;div class=&quot;list-item-img&quot;&gt; &lt;img :src=&quot;item.IMAGE1&quot; width=&quot;100%&quot; :onerror=&quot;errorImg&quot;/&gt;&lt;/div&gt; 商品列表页编程式导航的制作编程式导航 编写一个 goGoodsInfo() 方法，接收参数为 id，这里使用了 name 的导航方式 123goGoodsInfo (id) &#123; this.$router.push(&#123;name: &apos;Goods&apos;, params: &#123;goodsId: id&#125;&#125;)&#125; 给 html 加入 click 事件 123456789&lt;div class=&quot;list-item&quot; @click=&quot;goGoodsInfo(item.ID)&quot; v-for=&quot;(item,index) in goodList&quot; :key=&quot;index&quot; &gt; &lt;div class=&quot;list-item-img&quot;&gt; &lt;img :src=&quot;item.IMAGE1&quot; width=&quot;100%&quot; :onerror=&quot;errorImg&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;list-item-text&quot;&gt; &lt;div&gt;&#123;&#123;item.NAME&#125;&#125;&lt;/div&gt; &lt;div class=&quot;&quot;&gt;￥&#123;&#123;item.ORI_PRICE&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Goods.vue 页面的参数接收改造 以前使用的是 query 的方法接收，现在改用 params 的方法传递，所以要用到三元运算符做一下兼容处理 1this.goodsId = this.$route.query.goodsId ? this.$route.query.goodsId : this.$route.params.goodsId params 传参，路径不能使用 path，只能使用 name，不然取不到传的参数。 1this.$router.push(&#123;name: &apos;Goods&apos;, params: &#123;goodsId: id&#125;&#125;) 取数据时用 params 获取 1this.$route.params.goodsId query 传参，用的是 path，而不是 name，否则也会出错 1this.$router.push(&#123;path: &apos;/Goods&apos;, query: &#123;goodsId: id&#125;&#125;) 取数据使用 query 1this.$route.query.goodsId 价格过滤器的添加 首先引入过滤器 1import &#123;toMoney&#125; from &apos;@/filter/moneyFilter.js&apos; filters 属性的编写 12345filters:&#123; moneyFilter(money)&#123; return toMoney(money) &#125;&#125;, 在 template 中使用 1&lt;div class=&quot;&quot;&gt;￥ &#123;&#123;item.ORI_PRICE | moneyFilter&#125;&#125;&lt;/div&gt; 购物车页面的建立购物车页面不和后台交互，并且还要保持用户数据的持久化，主要知识点在 H5 新增的 localStorage 本地存储里 建立购物车页面 在 /src/components/pages 目录下新建一个 Cart.vue 文件，然后建立组件的基本结构，代码如下。 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; &#125;&lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 加入头部部分 123&lt;div class=&quot;navbar-div&quot;&gt; &lt;van-nav-bar title=&quot;购物车&quot; /&gt;&lt;/div&gt; 配置路由 打开 src/router/index.js 文件，增加 Cart 页面的路由配置 123456789101112131415161718192021import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import ShoppingMall from &apos;@/components/pages/ShoppingMall&apos;import Login from &apos;@/components/pages/Login&apos;import Register from &apos;@/components/pages/Register&apos;import Goods from &apos;@/components/pages/Goods&apos;import CategoryList from &apos;@/components/pages/CategoryList&apos;import Cart from &apos;@/components/pages/Cart&apos; Vue.use(Router) export default new Router(&#123; routes: [ &#123;path: &apos;/&apos;,name: &apos;ShoppingMall&apos;,component: ShoppingMall&#125;, &#123;path: &apos;/register&apos;,name: &apos;Register&apos;,component: Register&#125;, &#123;path: &apos;/login&apos;,name: &apos;Login&apos;,component: Login&#125;, &#123;path: &apos;/Goods&apos;,name: &apos;Goods&apos;,component: Goods&#125;, &#123;path: &apos;/CategoryList&apos;,name: &apos;CategoryList&apos;,component: CategoryList&#125;, &#123;path: &apos;/Cart&apos;,name: &apos;Cart&apos;,component: Cart&#125;, ]&#125;) 配置完路由，可以访问 http://localhost:8080/#/Cart 看看是不是可以正常访问 得到购物车数据方法的编写 进入页面要做的第一件事就是取得 localStorage 里的数据，首先在 data 里注册两个属性 cartInfo (购物车中商品的信息) 和 isEmpty (购物车是否为空的标识，方便页面呈现)，然后编写具体的 getCartInfo() 方法。代码如下 123456789101112131415161718192021222324export default &#123; data() &#123; return &#123; cartInfo: [], //购物车内的商品 isEmpty : false , //购物车是否为空，不为空则显示true，为空显示false &#125; &#125;, created()&#123; this.getCartInfo() &#125;, methods: &#123; //得到购物车的商品 getCartInfo() &#123; //判断localStorage里是否有购物车数据 if(localStorage.cartInfo)&#123; //如果有数据，我们去除并赋值给cartInfo this.cartInfo = JSON.parse(localStorage.cartInfo) &#125; //打印到控制台查看效果 console.log(&apos; this.cartInfo:&apos;+JSON.stringify( this.cartInfo)) this.isEmpty = this.cartInfo.length&gt;0 ? true : false &#125; &#125;,&#125; 购物车中商品的添加购物车商品的添加，其实就是对 localStorage 的操作和数组查找的使用，也就是 array.find() 操作。购物车添加的主要逻辑，并不放在 Cart.vue 页面里，我们放在 Goods.vue 页面里，也就是商品详情页面，这样做的好处是以后好扩展，并且不用传递参数，直接操作 localStorage 向购物车中添加商品 在 /components/pages/Goods.vue 里加入一个 addGoodsToCart 方法，然后编写下面的代码 1234567891011121314151617181920212223242526addGoodsToCart()&#123; //取出购物车内的商品数据 let cartInfo = localStorage.cartInfo ? JSON.parse(localStorage.cartInfo) :[] //判断购物车内是否已经有这个商品 //如果没有返回undeifnd，如果有返回第一个查找到的数据 let isHaveGoods=cartInfo.find(cart=&gt;cart.goodsId==this.goodsId) console.log(isHaveGoods) if(!isHaveGoods)&#123; //没有商品直接添加到数组中 //重新组成添加到购物车的信息 let newGoodsInfo=&#123; goodsId:this.goodsInfo.ID, Name:this.goodsInfo.NAME, price:this.goodsInfo.PRESENT_PRICE, image:this.goodsInfo.IMAGE1, count:1 &#125; cartInfo.push(newGoodsInfo) //添加到购物车 localStorage.cartInfo=JSON.stringify(cartInfo) //操作本地数据 Toast.success(&apos;添加成功&apos;) &#125;else&#123; Toast.success(&apos;已有此商品&apos;) &#125; this.$router.push(&#123;name:&apos;Cart&apos;&#125;) //进行跳转&#125; 完成上面代码编写后，向 “加入购物车” 按钮绑定 addGoodsToCart 事件方法 1&lt;van-button size=&quot;large&quot; type=&quot;primary&quot; @click=&quot;addGoodsToCart&quot;&gt;加入购物车&lt;/van-button&gt; 购物车清空和商品布局(Flex)现在购物车里已经可以添加商品数据了，现在来将这些数据显示出来 清空购物车按钮的制作 由于以前存在了一些不合法的数据，现在需要把 localStorage 里的 cartInfo 数据清空，这时候需要一个清空按钮 /src/components/pages/Cart.vue 里的模板里写一个 button 1234567891011121314151617181920// 清空购物车&lt;div class=&quot;card-title&quot;&gt; &lt;van-button size=&quot;small&quot; type=&quot;danger&quot; @click=&quot;clearCart&quot; plain&gt;清空购物车&lt;/van-button&gt;&lt;/div&gt;// CSS 样式.card-title&#123; height: 2rem; line-height:2rem; background-color: #fff; border-bottom:1px solid #E4E7ED; padding:5px; text-align: right;&#125;// 在 js 部分加入业务逻辑代码，清空 localStorage 里的 cartInfo 数据clearCart()&#123; localStorage.removeItem(&apos;cartInfo&apos;); this.cartInfo = [];&#125; 购物车商品的布局 使用 Flex 进行购物车商品的布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 在 main.js 文件中导入 Stepper 组件import &#123; Stepper &#125; from &apos;vant&apos;;Vue.use(Stepper);// 显示购物车中的商品&lt;div class=&quot;cart-list&quot;&gt; &lt;div class=&quot;pang-row&quot; v-for=&quot;(item,index) in cartInfo&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;pang-img&quot;&gt;&lt;img :src=&quot;item.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;pang-text&quot;&gt; &lt;div class=&quot;pang-goods-name&quot;&gt;&#123;&#123;item.Name&#125;&#125;&lt;/div&gt; &lt;div class=&quot;pang-control&quot;&gt; &lt;van-stepper v-model=&quot;item.count&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pang-goods-price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;// CSS样式代码如下.cart-list&#123; background-color: #fff;&#125;.pang-row&#123; display: flex; flex-direction: row; flex-wrap:nowrap; padding:0.5rem; font-size:0.85rem; border-bottom:1px solid #E4E7ED; &#125;.pang-img&#123; flex:6;&#125;.pang-text&#123; flex:14; padding-left:10px;&#125;.pang-control&#123; padding-top: 10px;&#125;.pang-goods-price&#123; flex:4; text-align: right;&#125; 购物车中的商品价格计算Vue 的双向数据绑定让计算价格变得相当容易，只要对 data 属性里的 cartInfo 属性进行编辑，就会自动呈现在页面上。 商品价格的格式化 引入过滤器，然后直接使用就可以了 引入 moneyFilter 过滤器 1import &#123;toMoney&#125; from &apos;@/filter/moneyFilter.js&apos; 编写过滤器 12345filters: &#123; moneyFilter(money)&#123; return toMoney(money); &#125;&#125;, 使用过滤器 1￥&#123;&#123;item.price | moneyFilter&#125;&#125; 改造 template，增加单个商品总价计算 直接写出数量和每个商品的总价，这里并不需要再 js 里写代码，直接在模板里使用乘法即可完成需求 1234567891011&lt;div class=&quot;pang-goods-price&quot;&gt; &lt;div&gt; ￥&#123;&#123;item.price | moneyFilter&#125;&#125; &lt;/div&gt; &lt;div&gt; x&#123;&#123;item.count&#125;&#125; &lt;/div&gt; &lt;div class=&quot;allPrice&quot;&gt; ￥&#123;&#123;item.price*item.count | moneyFilter&#125;&#125; &lt;/div&gt;&lt;/div&gt; 商品总价的计算 商品总价使用 Vue 的计算属性就可以搞定 12345678910111213141516171819202122232425// 首先编写模板，让商品总价显示出来&lt;!--显示总金额--&gt;&lt;div class=&quot;totalMoney&quot;&gt; 商品总价：￥ &#123;&#123;totalMoney | moneyFilter&#125;&#125;&lt;/div&gt;// 然后编写 CSS 样式.totalMoney&#123; text-align: right; background-color: #fff; border-bottom:1px solid #E4E7ED; padding: 5px;&#125;// 最后就是计算属性的编写computed:&#123; totalMoney()&#123; let allMoney = 0 this.cartInfo.forEach((item,index) =&gt; &#123; allMoney += item.price*item.count &#125;); localStorage.cartInfo=JSON.stringify(this.cartInfo) return allMoney &#125;&#125;, 先声明了一个总价格 allMoney，然后用循环读出 cartInfo 里的数据，并给 allMoney 进行赋值，完成后重新写入 localStorage 里，最后返回 allMoney，就完成了计算属性的编写 底部导航栏和子导航的制作现在已经有了三个页面，我们切换页面还是需要在地址栏输入，然后才能有所变化。现在我们来使用底部导航来切换页面 引入 tabbar 组件 在 /src/main.js 文件里引入两个 Vant 组件 Tabbar 和 Tabbarltem 12import &#123;Tabbar, TabbarItem&#125; from &apos;vant&apos;Vue.use(Tannar).use(TabbarItem) 新建 Main.vue 文件 在 /src/components/pages 下新建一个 Main.vue 文件，然后编写底部导航代码，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;div class=&quot;main-div&quot;&gt; &lt;router-view/&gt; &lt;/div&gt; &lt;van-tabbar v-model=&quot;active&quot; @change=&quot;changeTabbar(active)&quot;&gt; &lt;van-tabbar-item icon=&quot;shop&quot;&gt;首页&lt;/van-tabbar-item&gt; &lt;van-tabbar-item icon=&quot;records&quot;&gt;列表页&lt;/van-tabbar-item&gt; &lt;van-tabbar-item icon=&quot;cart&quot;&gt;购物车页&lt;/van-tabbar-item&gt; &lt;van-tabbar-item icon=&quot;contact&quot; info=&quot;20&quot;&gt;会员中心&lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; active: 0 &#125; &#125;, methods: &#123; changeTabbar(active) &#123; console.log(active) switch(active)&#123; case 0: this.$router.push(&#123;name:&apos;ShoppingMall&apos;&#125;) break; case 1: this.$router.push(&#123;name:&apos;CategoryList&apos;&#125;) break; case 2: this.$router.push(&#123;name:&apos;Cart&apos;&#125;) break; case 3: break; &#125; &#125; &#125;, &#125;&lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 子导航的制作 修改 /src/router/index.js 文件，把 Main.vue 的导航加入进来，然后把商城首页、商品列表页和购物车页面变成他的子导航 1234567891011121314151617181920212223242526272829import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import ShoppingMall from &apos;@/components/pages/ShoppingMall&apos;import Login from &apos;@/components/pages/Login&apos;import Register from &apos;@/components/pages/Register&apos;import Goods from &apos;@/components/pages/Goods&apos;import CategoryList from &apos;@/components/pages/CategoryList&apos;import Cart from &apos;@/components/pages/Cart&apos;import Main from &apos;@/components/pages/Main&apos; Vue.use(Router) export default new Router(&#123; routes: [ &#123;path: &apos;/main&apos;,name: &apos;Main&apos;,component: Main, children:[ &#123;path: &apos;/&apos;,name: &apos;ShoppingMall&apos;,component: ShoppingMall&#125;, &#123;path: &apos;/CategoryList&apos;,name: &apos;CategoryList&apos;,component: CategoryList&#125;, &#123;path: &apos;/Cart&apos;,name: &apos;Cart&apos;,component: Cart&#125;, ] &#125;, &#123;path: &apos;/register&apos;,name: &apos;Register&apos;,component: Register&#125;, &#123;path: &apos;/login&apos;,name: &apos;Login&apos;,component: Login&#125;, &#123;path: &apos;/Goods&apos;,name: &apos;Goods&apos;,component: Goods&#125;, ]&#125; 底部导航栏优化现在已经有了底部菜单，但是还是有一些小 Bug 需要处理一下。比如说从商品详情页面进入购物车时底部导航不跟随变化，还有有些页面拉不到底部。 购物车页面底部导航的处理 购物车页面出现底部导航不跟随变化的主要问题是：我们不是点击导航进入的，而是通过编程式导航进入的，这样导航栏就没有互动和触发事件，所以并没有发生变化。解决的思路就是跟踪获取路径，根据路径改变导航栏的变化。 先写一个方法获得路径，然后判断路径是不是 /Cart，是就把 this.active 变成 2 就可以了。代码如下 123456changeIabBarActive()&#123; this.nowPath = this.$router.path; if(this.nowPath == &apos;/Cart&apos;) &#123; this.active = 2; &#125;&#125; 在进入页面的生命周期里引入这个方法 123created()&#123; this.changeTabBarActive()&#125; 这时候这个 Bug 就解决了，如果页面中有多种这样的形式，可以逐一进行判断 商城首页不能来到底部的修改 产生这个问题的主要原因是在热销商品的层里没有加入高度，我们在这里个 .hot-goods 加入一段 CSS 样式就可以解决了 12345.hot-goods&#123; height: 130rem; overflow: hidden; background-color: #fff;&#125; 列表页 Bug 的解决 列表页也有拉不到底的问题，因为列表页我们是动态计算出来的高度，所以我们直接在动态计算的地方减去 50px 就可以了 12345mounted()&#123; let winHeight = document.documentElement.clientHeight; docuemnt.getElementById(&apos;leftNav&apos;).style.height = winHeight - 46 - 50 + &apos;px&apos;; document.getElementById(&apos;list-div&apos;).style.height = winHeight - 90 - 50 + &apos;px&apos;;&#125;,]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue + Koa2 移动电商项目学习笔记]]></title>
    <url>%2F2018%2F06%2F27%2FVue%2BKoa2%E7%A7%BB%E5%8A%A8%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20(%20%E4%B8%80%20)%2F</url>
    <content type="text"><![CDATA[Vue + Koa2 移动电商项目学习笔记 ( 一 )开发环境搭建 建立文件夹 新建 SmileVue 文件夹 使用 vue-cli 生成项目目录 使用 npm -v 检测 npm 版本，尽量使用 5.X 以上版本 全局安装 vue-cli, npm install vue-cli -g 在终端中输入 vue init webpack 来初始化项目， 项目名需要小写 测试环境是否安装成功 使用 npm run dev 进行测试环境的打开 在浏览器中输入 localhost:8080 进行测试 引入 Vant 组件库 安装 Vant npm i vant -S 引入 Vant 的方法一 (不推荐) 安装好 Vant 后，可以使用以前常用的方法进行引入—这是一种全局引入的方法 12345// main.jsimport Vant from &apos;vant&apos;import &apos;vant/lib/vant-css/index.css&apos;Vue.use(vant) 不推荐这种方法的原因是在最后打包发布的时候会增加包的大小， Vue 的 SPA 首屏打开时间本来就有些慢 引入 Vant 推荐方法 Vant 是支持 babel-plugin-import 引入的，可以按需引入组件模块，并且不用管理我们的样式，是现在 Vue 项目组件库的主流引入方法。 安装 babel-plugin-import npm i babel-plugin-import -D 或者 npm install babel-plugin-import –save-dev 在 .babelrc 中配置 plugins 12345&quot;plugins&quot;: [ &quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;, [&quot;import&quot;,&#123;&quot;libraryName&quot;:&quot;vant&quot;,&quot;style&quot;:true&#125;]] 按需使用 Vant 组件 在设置好 .babelrc 后，就可以按需引入 Vant 框架了。比如引入一个 Button 组件 123456// main.jsimport &#123; Button &#125; from &apos;vant&apos;Vue.use(Button)// 有了这段代码之后，我们就可以在需要的组件页面中假如 Button 了&lt;van-button type=&quot;primary&quot;&gt;主要按钮&lt;/van-button&gt; 移动端屏幕适配基础 常见移动 Web 布局适配方法 固定高度，固定百分比：过时的方法 Media Query (媒体查询)：现在比较主流的适配方案 flex 布局： 主流的布局方式，在项目中尽量采用 flex + rem 的方式进行布局和完成移动端的适配。 rem 单位介绍 适配原理：将 px 替换成 rem，动态修改 html 的 font-size 适配。它可以很好的根据根元素的字体大小来进行变化，从而达到各种屏幕基本一致的效果体验。 JS 控制适配屏幕 12345678910// 得到手机屏幕的宽度let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;// 得到 html 的 DOM 元素let htmlDom = document.getElementsByTagName(&apos;html&apos;)[0];// 设置根元素字体大小htmlDom.style.fontSize = htmlWidth/20 + &apos;px&apos;;// 当页面很大的时候，我们的移动适配方案会呈现很大的字体，所以加一个判断，解决页面字体过大的问题// 当页面宽度大于 750px 时, 把页面的宽度设置为 750pxif ( htmlWidth&amp;gt; 750 ) &#123; htmlWidth=750 &#125; 首页布局和路由设置首页路由的配置： 打开路由配置页面：src/router/index.js，先删除 vue-cli 自动生成的 HelloWorld.Vue 的配置，然后加入新的路由配置 1234567891011import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import ShoppingMall from &apos;@/components/pages/ShoppingMall&apos; // @ 表示 项目 src 的目录Vue.use(Router)export default new Router(&#123; routes: [ &#123;path: &apos;/&apos;,name: &apos;ShoppingMall&apos;,component: ShoppingMall&#125; ]&#125;) 建立首页组件 删除 HelloWorld.vue 文件，建立 ShoppingMall.vue 文件。代码如下： 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; data () &#123; return &#123; msg: &apos;Shopping Mall&apos; &#125; &#125;&#125;&lt;/script&gt; Vant 布局 使用 Vant 的布局需要先进行按需引入，直接在 main.js 里引入 Row 和 Col 组件 import { Button, Row, Col } from ‘vant’ Vue.use(Button).use(Row).use(Col) Vant 采用 24 格布局法，我们控制这 24 等分的比例就可以实现布局 12345&lt;van-row&gt; &lt;van-col span=&quot;8&quot;&gt;span: 8&lt;/van-col&gt; &lt;van-col span=&quot;8&quot;&gt;span: 8&lt;/van-col&gt; &lt;van-col span=&quot;8&quot;&gt;span: 8&lt;/van-col&gt;&lt;/van-row&gt; 首页搜索区域的布局搜索条的布局 利用 van-row 和 van-col 快速布局一个搜索条的 HTML 骨架 12345678910111213&lt;div class=&quot;search-bar&quot;&gt; &lt;van-row&gt; &lt;van-col span=&quot;3&quot;&gt;icon&lt;/van-col&gt; &lt;van-col span=&quot;16&quot;&gt;serach input&lt;/van-col&gt; &lt;van-col span=&quot;5&quot;&gt;button&lt;/van-col&gt; &lt;/van-row&gt;&lt;/div&gt;.search-bar&#123; height: 2.2rem; background-color: #e5017d; line-height:2.2rem; &#125; 下载 icon 图标 在 src/assets/ 目录下新建 images 文件夹，以后所有的项目图片都放在这里 引入图片 把图片用 require 引进到页面中 12345678910// 通过绑定属性的方法插入图片&lt;van-col span=&quot;3&quot;&gt;&lt;img :src=&quot;locationIcon&quot; width=&quot;100%&quot; /&gt;&lt;/van-col&gt;export default &#123; data() &#123; return &#123; locationIcon: require(&apos;../../assets/images/location.png&apos;) &#125; &#125;,&#125; 写 input 和 button 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div&gt;&lt;!--search bar layout--&gt;&lt;div class=&quot;search-bar&quot;&gt; &lt;van-row gutter=&quot;5&quot;&gt; &lt;van-col span=&quot;3&quot;&gt;&lt;img :src=&quot;locationIcon&quot; width=&quot;80%&quot; class=&quot;location-icon&quot; /&gt;&lt;/van-col&gt; &lt;van-col span=&quot;16&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;search-input&quot;/&gt; &lt;/van-col&gt; &lt;van-col span=&quot;5&quot;&gt;&lt;van-button size=&quot;mini&quot;&gt;查找&lt;/van-button&gt;&lt;/van-col&gt; &lt;/van-row&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; locationIcon: require(&apos;../../assets/images/location.png&apos;) &#125; &#125;,&#125;&lt;/script&gt; &lt;style scoped&gt; .search-bar&#123; height: 2.2rem; background-color: #e5017d; line-height:2.2rem; &#125; .search-input&#123; width:100%; height: 1.3rem; border-top:0px; border-left:0px; border-right:0px; border-bottom: 1px solid 1px !important ; background-color: #e5017d; color:#fff; &#125; .location-icon&#123; padding-top: .2rem; padding-left: .3rem; &#125;&lt;/style&gt; 首页轮播图的制作按需加载 Swipe 组件 在 /src/main.js 下按需引入 swipe import { Swipe, SwipeItem } from ‘vant’; Vue.use(Swipe).use(SwipeItem); 现在的 main.js 样式如下： import { Button, Row, Col ,Search , Swipe , SwipeItem } from ‘vant’ Vue.use(Button).use(Row).use(Col).use(Search).use(Swipe).use(SwipeItem) 下载图片 图片链接: 开始制作轮播图 在 js 部分写入一个 data 参数 bannerPicArray，把图片地址放入到里边 123456789101112131415161718192021222324252627282930// /src/components/pages/ShoppingMall.vuedata() &#123; return &#123; locationIcon: require(&apos;../../assets/images/location.png&apos;), bannerPicArray:[ &#123;imageUrl:&apos;http://7xjyw1.com1.z0.glb.clouddn.com/simleVueDemoPic001.jpg&apos;&#125;, &#123;imageUrl:&apos;http://7xjyw1.com1.z0.glb.clouddn.com/simleVueDemoPic002.jpg&apos;&#125;, &#123;imageUrl:&apos;http://7xjyw1.com1.z0.glb.clouddn.com/simleVueDemoPic003.jpg&apos;&#125;, ] &#125; &#125;, // 模板如下 &lt;!--swipwer area--&gt;&lt;div class=&quot;swiper-area&quot;&gt; &lt;van-swipe :autoplay=&quot;1000&quot;&gt; &lt;van-swipe-item v-for=&quot;(banner,index) in bannerPicArray&quot; :key=&quot;index&quot;&gt; &lt;img :src=&quot;banner.imageUrl&quot; width=&quot;100%&quot;/&gt; &lt;/van-swipe-item&gt; &lt;/van-swipe&gt;&lt;/div&gt;// CSS 代码.swiper-area&#123; overflow: hidden; clear: both; width:20rem; clear:both;&#125; 利用 Vant 实现图片轮播的懒加载 import { Button, Row, Col ,Search , Swipe , SwipeItem , Lazyload } from ‘vant’ Vue.use(Button).use(Row).use(Col).use(Search).use(Swipe).use(SwipeItem).use(Lazyload) // 修改 template 区域，加入v-lazy=&quot;banner.imageUrl&quot;就可以图片的懒加了 easyMock 和 Axios 的使用Mock 数据准备 进入 easy-Mock axios 的引入 直接使用 npm install 进行安装 npm install –save axios 安装之后在要使用的页面组件中进行引入 import axios from ‘axios’ 然后在 created 的声明周期里取得数据 1234567891011created()&#123; axios(&#123; url: &apos;https://www.easy-mock.com/mock/5ae2427800247c2aa1efe442/SmileVue/&apos;, method: &apos;get&apos;, &#125;) .then(response =&gt; &#123; console.log(response) &#125;) .catch((error) =&gt; &#123; &#125;)&#125; 如果能取得数据后，说明已经 Mock 成功了，那接下来就用这些数据进行布局 Mock 数据的使用 flex 布局首页商品分类栏的布局 使用 flex 布局，是因为 van-row 是 24 格布局，5 个元素是不好分的，所以使用 flex 布局。 在 js 代码 created 的 axios then 方法里写入下面代码 ( 提取 Mock 数据 ) 1234567891011121314created()&#123; axios(&#123; url: &apos;https://www.easy-mock.com/mock/5ae2eeb23fbbf24d8cd7f0b6/SmileVue/index&apos;, method: &apos;get&apos;, &#125;) .then(response =&gt; &#123; console.log(response) if(response.status==200)&#123; this.category=response.data.data.category; &#125; &#125;) .catch((error) =&gt; &#123; &#125;)&#125; 编写 HTML 代码 123456&lt;div class=&quot;type-bar&quot;&gt; &lt;div v-for=&quot;(cate,index) in category&quot; :key=&quot;index&quot; &gt; &lt;img v-lazy=&quot;cate.image&quot; width=&quot;90%&quot; /&gt; &lt;span&gt;&#123;&#123;cate.mallCategoryName&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS 样式 1234567891011121314.type-bar&#123; background-color: #fff; margin:0 .3rem .3rem .3rem; border-radius: .3rem; font-size:14px; display: flex; flex-direction:row; flex-wrap:nowrap; &#125; .type-bar div&#123; padding: .3rem; font-size: 12px; text-align: center; &#125; 广告 Banner 的布局 12345678// 先在 created 里获取数据，然后进行 HTML 骨架编写，最后进行 CSS 样式的调整this.adBanner = response.data.data.advertesPicture //获得广告图片// HTML 代码编写&lt;!--AD banner area--&gt;&lt;div class=&quot;ad-banner&quot;&gt; &lt;img v-lazy=&quot;adBanner.PICTURE_ADDRESS&quot; width=&quot;100%&quot;&gt;&lt;/div&gt; 改造 swipe 组件 123456789101112// 前面已经用静态数据模拟了轮播效果，现在有了Mock数据，完全可以用Mack数据代替。先获取轮播图片地址数组。this.bannerPicArray = response.data.data.slides //轮播图片// 然后修改html模版中的数据绑定就可以了&lt;div class=&quot;swiper-area&quot;&gt; &lt;van-swipe :autoplay=&quot;1000&quot;&gt; &lt;van-swipe-item v-for=&quot;(banner,index) in bannerPicArray&quot; :key=&quot;index&quot;&gt; &lt;img v-lazy=&quot;banner.image&quot; width=&quot;100%&quot;/&gt; &lt;/van-swipe-item&gt; &lt;/van-swipe&gt;&lt;/div&gt; 商品推荐 vue-awesome-swiper先来简单的布局 12345678910111213141516171819202122// 我们先把基本的布局做好，在src/components/pages/ShoppingMall.vue，里编写如下html和CSS代码，这里只是简单的布局。&lt;!--Recommend goods area--&gt;&lt;div class=&quot;recommend-area&quot;&gt; &lt;div class=&quot;recommend-title&quot;&gt; 商品推荐 &lt;/div&gt; &lt;div class=&quot;recommend-body&quot;&gt; &lt;/div&gt;&lt;/div&gt;// CSS.recommend-area&#123; background-color: #fff; margin-top: .3rem; &#125; .recommend-title&#123; border-bottom:1px solid #eee; font-size:14px; padding:.2rem; color:#e5017d; &#125; 安装 vue-awesome-swiper npm install vue-awesome-swiper –save 引入 vue-awesome-swiper 的两种方式 全局引入 123456// 可以直接使用全局引入import Vue from &apos;vue&apos;import VueAwesomeSwiper from &apos;vue-awesome-swiper&apos;// require stylesimport &apos;swiper/dist/css/swiper.css&apos;Vue.use(VueAwesomeSwiper, /* &#123; default global options &#125; */) 以组件的形式引入 123456789// 以组件形式引入 这种方式是在需要的页面以component 的形式引入，好处就是依赖性不强。import &apos;swiper/dist/css/swiper.css&apos;import &#123; swiper, swiperSlide &#125; from &apos;vue-awesome-swiper&apos;export default &#123; components: &#123; swiper, swiperSlide &#125;&#125; 获取推荐商品数据 ​ 在javascript部分的data里加入recommendGoods:[]属性，然后在created生命周期里获得. this.recommendGoods = response.data.data.recommend //推荐商品 编写 swiper 的 html 12345678910111213141516171819202122&lt;!--swiper--&gt;&lt;swiper :options=&quot;swiperOption&quot;&gt; &lt;swiper-slide v-for=&quot; (item ,index) in recommendGoods&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;recommend-item&quot;&gt; &lt;img :src=&quot;item.image&quot; width=&quot;80%&quot; /&gt; &lt;div&gt;&#123;&#123;item.goodsName&#125;&#125;&lt;/div&gt; &lt;div&gt;￥&#123;&#123;item.price&#125;&#125; (￥&#123;&#123;item.mallPrice&#125;&#125;)&lt;/div&gt; &lt;/div&gt; &lt;/swiper-slide&gt;&lt;/swiper&gt;// CSS.recommend-body&#123; border-bottom: 1px solid #eee; &#125; .recommend-item&#123; width:99%; border-right: 1px solid #eee; font-size: 12px; text-align: center; &#125; vue-awesome-swiper 详解1vue-awesome-swiper组件在开发中是经常使用的，它可以作轮播图，可以作滚动。 一个最简单的轮播图 这里作一个单独的组件，这样不会污染项目中的文件，这个只是一个最简单默认的swiper，在components目录下新建一个文件夹swiper，然后新建一个swiperDefault.vue文件。写入如下代码: 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div &gt; &lt;swiper&gt; &lt;swiper-slide class=&quot;swiper-slide&quot; v-for=&quot;(item, index) in slide&quot; :key=&quot;index&quot;&gt; Slide &#123;&#123;item&#125;&#125; &lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import &apos;swiper/dist/css/swiper.css&apos; import &#123; swiper, swiperSlide &#125; from &apos;vue-awesome-swiper&apos; export default &#123; data() &#123; return &#123; slide: [1,2,3,4,5,6] &#125; &#125;, components:&#123;swiper,swiperSlide&#125; &#125;&lt;/script&gt; &lt;style scoped&gt; .swiper-slide&#123; height: 4rem; text-align: center; padding-top: 3rem; border-bottom: 1px solid #ccc; &#125;&lt;/style&gt; 代码写好后，在shoppingMall.vue文件里进行引入使用。 import swiperDefault from ‘../swiper/swiperDefault’ 然后注册组件, components:{swiper,swiperSlide,swiperDefault}, 注册好后，直接在template里使用就可以了. 添加分页器 123456789// 我们现在data里进行配置，代码如下：swiperOption:&#123; pagination:&#123; el:&apos;.swiper-pagination&apos; &#125;&#125;// 然后在template标签里加入一个div用于显示分页器,注意的是要在swiper-slide外层&lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; 最后是在swiper标签里加入 :options=&quot;swiperOption&quot;。就实现了有分页期的效果。 整体代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div &gt; &lt;swiper :options=&quot;swiperOption&quot;&gt; &lt;swiper-slide class=&quot;swiper-slide&quot; v-for=&quot;(item, index) in slide&quot; :key=&quot;index&quot;&gt; Slide &#123;&#123;item&#125;&#125; &lt;/swiper-slide&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import &apos;swiper/dist/css/swiper.css&apos; import &#123; swiper, swiperSlide &#125; from &apos;vue-awesome-swiper&apos; export default &#123; data() &#123; return &#123; slide: [1,2,3,4,5,6], swiperOption:&#123; pagination:&#123; el:&apos;.swiper-pagination&apos; &#125; &#125; &#125; &#125;, components:&#123;swiper,swiperSlide&#125; &#125;&lt;/script&gt; &lt;style scoped&gt; .swiper-slide&#123; height: 4rem; text-align: center; padding-top: 3rem; border-bottom: 1px solid #ccc; &#125;&lt;/style&gt; 竖屏切换效果 在配置项里直接配置direction就可以了，配置竖屏代码如下 123456swiperOption:&#123; direction:&apos;vertical&apos;, pagination:&#123; el:&apos;.swiper-pagination&apos; &#125;&#125; 整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div &gt; &lt;swiper class=&quot;swiper&quot; :options=&quot;swiperOption&quot;&gt; &lt;swiper-slide class=&quot;swiper-slide&quot; v-for=&quot;(item, index) in slide&quot; :key=&quot;index&quot;&gt; Slide &#123;&#123;item&#125;&#125; &lt;/swiper-slide&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import &apos;swiper/dist/css/swiper.css&apos; import &#123; swiper, swiperSlide &#125; from &apos;vue-awesome-swiper&apos; export default &#123; data() &#123; return &#123; slide: [1,2,3,4,5,6], swiperOption:&#123; direction:&apos;vertical&apos;, pagination:&#123; el:&apos;.swiper-pagination&apos; &#125; &#125; &#125; &#125;, components:&#123;swiper,swiperSlide&#125; &#125;&lt;/script&gt; &lt;style scoped&gt; .swiper-slide&#123; height: 4rem; text-align: center; line-height: 4rem; &#125; .swiper&#123; height: 7rem; border-top:1px solid #ccc; border-bottom:1px solid #ccc; &#125;&lt;/style&gt; vue-awesome-swiper 详解2区域滚动效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div &gt; &lt;swiper class=&quot;swiper&quot; :options=&quot;swiperOption&quot;&gt; &lt;swiper-slide class=&quot;text&quot;&gt; &lt;div class=&quot;centent&quot;&gt; 一大堆文章......... &lt;/div&gt; &lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import &apos;swiper/dist/css/swiper.css&apos; import &#123; swiper, swiperSlide &#125; from &apos;vue-awesome-swiper&apos; export default &#123; data() &#123; return &#123; swiperOption:&#123; direction:&apos;vertical&apos;, slidesPerView: &apos;auto&apos;, freeMode:true, mousewheel:true &#125; &#125; &#125;, components:&#123;swiper,swiperSlide&#125; &#125;&lt;/script&gt; &lt;style scoped&gt; .swiper&#123; height: 300px; overflow: hidden; &#125; .text&#123; font-size: 18px !important; text-align: left; padding:30px; height: auto; -webkit-box-sizing: border-box; box-sizing: border-box; &#125;&lt;/style&gt; 重点看一下 options 的加入属性： direction： ‘vertical’ 设置竖排显示 slidesPerView: ‘auto’ 设置同屏显示的数量， 默认为 1， 这里使用 auto 是随意的意思。 freeMode： true 默认为 false， 普通模式： slide 滑动时只滑动一格，并自动贴合 wrapper，设置为 true 则变为 free 模式， slide 会根据惯性滑动可能不止一格且不会贴合。 mousewheel： true 开启鼠标滚轮控制 Swiper 切换。 可是只鼠标选项， 或 true 使用默认值。 让分页器可以自由选择 在实际工作当中分页器都是可以自由选择的，只要配置一下 Options 的 clickable 数据就可以了。注意这个属性要配置在 pagination 下面，才能起作用。 1234pagination: &#123; el: &apos;.swiper-pagination&apos;, clickable: true&#125; 无线循环滚动 还有一个需求是无限循环滚动，不要到底了就要往回滚动，这个只要在 options 里加一个 loop： true 就可以实现了。 123456789101112data() &#123; return &#123; slide: [1,2,3,4,5,6], swiperOption:&#123; loop:true, pagination:&#123; el:&apos;.swiper-pagination&apos;, clickable:true &#125; &#125; &#125;&#125;, 首页楼层区域布局不规则的布局 第一步： 先获取楼层一的数据 在 data 里注册一个 floor1 的数组变量 floor1：[], 在 axios 里得到数据。 1234this.floor1 = response.data.data.floor1 //楼层1数据this.floor1_0 =this.floor1[0]this.floor1_1 =this.floor1[1]this.floor1_2 =this.floor1[2] 第二步： 编写 HTML 代码 在编写 HTML 的时候需要注意结构层次，原则就是先统一规划大体，然后在调整局部 12345678910&lt;!--floor one area--&gt;&lt;div class=&quot;floor&quot;&gt; &lt;div class=&quot;floor-anomaly&quot;&gt; &lt;div class=&quot;floor-one&quot;&gt;&lt;img :src=&quot;floor1_0.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;div&gt; &lt;div class=&quot;floor-two&quot;&gt;&lt;img :src=&quot;floor1_1.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;img :src=&quot;floor1_2.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 第三步： 编写 CSS 样式 主要使用了 flex 布局和 box-sizing 12345678910111213141516171819.floor-anomaly&#123; display: flex; flex-direction:row; background-color: #fff; border-bottom:1px solid #ddd; &#125; .floor-anomaly div&#123; width:10rem; box-sizing: border-box; -webkit-box-sizing: border-box; &#125; .floor-one&#123; border-right:1px solid #ddd; &#125; .floor-two&#123; border-bottom:1px solid #ddd; &#125; 规则部分的布局 第一步： 布局 HTML 12345&lt;div class=&quot;floor-rule&quot;&gt; &lt;div v-for=&quot;(item ,index) in floor1.slice(3)&quot; :key=&quot;index&quot;&gt; &lt;img :src=&quot;item.image&quot; width=&quot;100%&quot;/&gt; &lt;/div&gt;&lt;/div&gt; 第二步： 编写 CSS 12345678910111213141516.floor-rule&#123; display: flex; flex-direction: row; flex-wrap:wrap; background-color: #fff; &#125; .floor-rule div&#123; -webkit-box-sizing: border-box; box-sizing: border-box; width:10rem; border-bottom:1px solid #ddd; &#125; .floor-rule div:nth-child(odd)&#123; border-right: 1px solid #ddd; &#125; 楼层标题的布局 自定义样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* 完整代码 */ &lt;!--floor one area--&gt; &lt;div class=&quot;floor&quot;&gt; &lt;div class=&quot;floor-anomaly&quot;&gt; &lt;div class=&quot;floor-one&quot;&gt;&lt;img :src=&quot;floor1_0.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;div&gt; &lt;div class=&quot;floor-two&quot;&gt;&lt;img :src=&quot;floor1_1.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;img :src=&quot;floor1_2.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;floor-rule&quot;&gt; &lt;div v-for=&quot;(item ,index) in floor1.slice(3)&quot; :key=&quot;index&quot;&gt; &lt;img :src=&quot;item.image&quot; width=&quot;100%&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; data () &#123; return &#123; locationIcon: require(&apos;../../assets/images/location.png&apos;), bannerPicArray:[], category: &apos;&apos;, adBanner: &apos;&apos;, recommendGoods: [], floor1: [] &#125; &#125;, created()&#123; axios(&#123; url: &apos;https://www.easy-mock.com/mock/5b336ab6e312d1110939a921/SmileVue/SmileVue&apos;, method: &apos;get&apos;, &#125;) .then(response =&gt; &#123; // console.log(response) if(response.status==200)&#123; this.bannerPicArray = response.data.data.slides; //轮播图片 this.category=response.data.data.category; this.adBanner = response.data.data.advertesPicture; //获得广告图片 this.recommendGoods = response.data.data.recommend; //推荐商品 this.floor1 = response.data.data.floor1; //楼层1数据 this.floor1_0 = this.floor1[0]; this.floor1_1 = this.floor1[1]; this.floor1_2 = this.floor1[2]; &#125; &#125;) .floor-anomaly&#123; display: flex; flex-direction:row; background-color: #fff; border-bottom:1px solid #ddd; &#125; .floor-anomaly div&#123; width:10rem; box-sizing: border-box; -webkit-box-sizing: border-box; &#125; .floor-one&#123; border-right:1px solid #ddd; &#125; .floor-two&#123; border-bottom:1px solid #ddd; &#125; .floor-rule&#123; display: flex; flex-direction: row; flex-wrap:wrap; background-color: #fff; &#125; .floor-rule div&#123; -webkit-box-sizing: border-box; box-sizing: border-box; width:10rem; border-bottom:1px solid #ddd; &#125; .floor-rule div:nth-child(odd)&#123; border-right: 1px solid #ddd; &#125; 楼层组件的封装和 watch 的使用为了代码复用和少写一些代码，将楼层这部分分封装成一个传递参数的组件，并使用 watch 来监听参数的变化，达到正确渲染的目的。 编写组件 在 src/components/ 下新建一个 component 的文件夹， 进入文件夹， 新建 floorComponent.vue 文件， 用来编写楼层组件 在编写的时候，先从页面中把相对应的 html 模板和 CSS 代码拷进来，然后再进行改造。 全部组件代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;div&gt; &lt;!--floor one area--&gt; &lt;div class=&quot;floor&quot;&gt; &lt;div class=&quot;floor-anomaly&quot;&gt; &lt;div class=&quot;floor-one&quot;&gt;&lt;img :src=&quot;floorData0.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;div&gt; &lt;div class=&quot;floor-two&quot;&gt;&lt;img :src=&quot;floorData1.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;div&gt;&lt;img :src=&quot;floorData2.image&quot; width=&quot;100%&quot; /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;floor-rule&quot;&gt; &lt;div v-for=&quot;(item ,index) in floorData.slice(3)&quot; :key=&quot;index&quot;&gt; &lt;img :src=&quot;item.image&quot; width=&quot;100%&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; props:[&apos;floorData&apos;], data() &#123; return &#123; floorData0:&#123;&#125;, floorData1:&#123;&#125;, floorData2:&#123;&#125; &#125; &#125;, created()&#123; //这里写得不到数据，应为数据是延迟返回的 &#125;, watch:&#123; floorData:function(val)&#123; console.log(this.floorData) this.floorData0=this.floorData[0] this.floorData1=this.floorData[1] this.floorData2=this.floorData[2] &#125; &#125; &#125;&lt;/script&gt; &lt;style scoped&gt; .floor-anomaly&#123; display: flex; flex-direction:row; background-color: #fff; border-bottom:1px solid #ddd; &#125; .floor-anomaly div&#123; width:10rem; box-sizing: border-box; -webkit-box-sizing: border-box; &#125; .floor-one&#123; border-right:1px solid #ddd; &#125; .floor-two&#123; border-bottom:1px solid #ddd; &#125; .floor-rule&#123; display: flex; flex-direction: row; flex-wrap:wrap; background-color: #fff; &#125; .floor-rule div&#123; -webkit-box-sizing: border-box; box-sizing: border-box; width:10rem; border-bottom:1px solid #ddd; &#125; .floor-rule div:nth-child(odd)&#123; border-right: 1px solid #ddd; &#125;&lt;/style&gt; 由于组件中的数据是从远程拿来的，所以刚开始数据是空的，所以组件渲染不出来。需要加入 watch 属性来监听传递过来值的变化，当变化时， 再给 1， 2， 3副图片进行赋值操作。 最后根据赋值来改造 template 的 HTML 结构 引入组件 在 ShoppingMall.vue 中引入组件， 首先使用 import 进行引入 import floorComponent from ‘../component/floorComponent’ 在 components 属性里注册组件 components: {floorComponent} 完成上面两步就可以直接在 template 里用标签的形式使用了 使用绑定属性的形式传入需要的值， 按照这种方法， 就可以直接引入其他 3 个楼层了。 删除页面中的无用代码 有了组件后，页面中的很多代码都变得无用了，我们需要作一下处理 楼层组件的完善楼层组件标题区域制作 首先在 floorComponent.vue 组件的 template 区域加入 HTML 代码 然后编写 css 样式 123456.floor-title&#123; text-align:center; font-size:14px; height: 1.8rem; line-height: 1.8rem; &#125; 其次加入 props 属性的编写 props: [ ‘floorData’, ‘floorTitle’ ], 这样我们就完成了楼层组件区域的制作，并且可以在说那个的时候传递过来一个标题了。 给头部区域传值 先在 ShoppingMall.vue 的 Data 里声明一个叫 floorName 的值。 然后在 axios 里进行赋值。 this.floorName = response.data.data.floorName // 楼层名称 最后修改一下 template 里的写法就可以使用了 完成其他两个楼层的代码编写 先在 data 里进行声明 12345678910111213141516data() &#123; return &#123; swiperOption: &#123; slidesPerView:3, &#125;, locationIcon: require(&apos;../../assets/images/location.png&apos;), bannerPicArray:[], // 轮播图片 category:[], //商品类别标签栏 adBanner:&apos;&apos;, //广告图片 recommendGoods:[], //推荐商品 floor1:[], //楼层1的数据 floor2:[], //楼层1的数据 floor3:[], //楼层1的数据 floorName:&#123;&#125; //楼层名称 &#125;&#125;, 在 axios 里获得数据 123this.floor1 = response.data.data.floor1 //楼层1数据this.floor2 = response.data.data.floor2 //楼层2数据this.floor3 = response.data.data.floor3 //楼层3数据 在模板 template 里使用组件 123&lt;floorComponent :floorData=&quot;floor1&quot; :floorTitle=&quot;floorName.floor1&quot;&gt;&lt;/floorComponent&gt;&lt;floorComponent :floorData=&quot;floor2&quot; :floorTitle=&quot;floorName.floor2&quot;&gt;&lt;/floorComponent&gt;&lt;floorComponent :floorData=&quot;floor3&quot; :floorTitle=&quot;floorName.floor3&quot;&gt;&lt;/floorComponent&gt; Filter 在实战中的使用编写过滤器通用方法 因为过滤器都是需要在很多组件中进行使用，所以要编写一个比较通用的方法。先在 src 文件夹下建立一个 filter 文件夹， 然后在 filter 文件夹下建立一个 moneyFilter.js 文件。 这时候就可以编写格式化钱的方法， 我们这里使用了 toFixed() 方法。 1234567891011export function toMoney (money) &#123; let newMoney = money; if (newMoney) &#123; newMoney = newMoney.toFixed(2); &#125; else &#123; newMoney = 0; newMoney = newMoney.toFined(2); &#125; return newMoney;&#125;// 这个方法并不完善，后面会进行修改 引入 Filter import { toMoney } from “@/filter/moneyFilter.js” 这里的 @ 代表的是 src 目录的意思，这个是 webpack 的配置，我们可以在 /build/webpack.base.conf.js 里找到这个配置项。 编写 Vue 里的 filter 属性 vue 是支持 filter 属性的，之前只是方法，现在要在 Vue 文件里编写属性. 123456filters: &#123; moneyFilter(money) &#123; return toMoney(money) &#125;&#125;,// 这里要注意 filter 的名字可以随便起，但是使用的 toMoney 方法，要和上边引入的一样。 在 template 中使用 filter 123直接在使用价格的地方使用 &#123;&#123; item.price | moneyFilter &#125;&#125; 就可以了// 注: 上面这句话在此文章中必须要写在 代码框或者引用框 中, 否则文章无法提交到博客中, 详细报错信息稍后会在另一片文章中作出说明. 优化 filter 通用方法 1234// 上边的通用方法做的并不完善，在这里需要优化一下export function toMoney(money = 0)&#123; return money.toFixed(2)&#125; 首页热卖模块的 Van-list 组件的使用html + css 部分的编写 12345678910111213141516// html 代码，这些代码是写在 ShoppingMall.vue 文件中的&lt;!--Hot Area--&gt;&lt;div class=&quot;hot-area&quot;&gt; &lt;div class=&quot;hot-title&quot;&gt;热卖商品&lt;/div&gt; &lt;div class=&quot;hot-goods&quot;&gt; &lt;!--这里需要一个list组件--&gt; &lt;/div&gt;&lt;/div&gt;// CSS 部分代码.hot-area&#123; text-align: center; font-size:14px; height: 1.8rem; line-height:1.8rem; &#125; Vant 列表 (List) 组件的使用 引入 List 组件： 在 /src/main.js 文件中引入 List 组件 import { List } from “vant” Vue.use( List ) 构造数据： 在 data 里声明 hotGoods data(){ hotGoods: [] } // 热卖商品 在 axios 里获得数据 this.hotGoods = response.data.data.hotGoods // 热卖商品 加入 List 组件，并使用 van-row 布局 12345678910111213&lt;!--Hot Area--&gt;&lt;div class=&quot;hot-area&quot;&gt; &lt;div class=&quot;hot-title&quot;&gt;热卖商品&lt;/div&gt; &lt;div class=&quot;hot-goods&quot;&gt; &lt;van-list&gt; &lt;van-row gutter=&quot;20&quot;&gt; &lt;van-col span=&quot;12&quot; v-for=&quot;( item, index) in hotGoods&quot; :key=&quot;index&quot;&gt; &lt;div&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;/van-col&gt; &lt;/van-row&gt; &lt;/van-list&gt; &lt;/div&gt;&lt;/div&gt; 商品显示组件的编写 新建 /src/component/goodsInfoComponent.vue 文件，用来制作商品组件 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;div class=&quot;goods-image&quot;&gt; &lt;img v-lazy=&quot;goodsImage&quot; width=&quot;90%&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;goods-name&quot;&gt;&#123;&#123;goodsName&#125;&#125;&lt;/div&gt; &lt;div class=&quot;goods-price&quot;&gt;￥&#123;&#123;goodsPrice | moneyFilter &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import &#123;toMoney&#125; from &apos;@/filter/moneyFilter.js&apos; export default &#123; props:[&apos;goodsImage&apos;,&apos;goodsName&apos;,&apos;goodsPrice&apos;], filters:&#123; moneyFilter(money)&#123; return toMoney(money) &#125; &#125;, &#125;&lt;/script&gt; &lt;style scoped&gt; .goods-name&#123; padding: 0 8px; overflow: hidden; text-overflow: ellipsis; white-space:nowrap; &#125;&lt;/style&gt; 在 ShoppingMall.vue 里引入，并且在 components 里声明一下 import goodsInfo from ‘../component/goodsInfoComponent’ 在模板中使用组件 12345&lt;van-row gutter=&quot;20&quot;&gt; &lt;van-col span=&quot;12&quot; v-for=&quot;(item,index) in hotGoods&quot; :key=&quot;index&quot;&gt; &lt;goods-info :goodsImage=&quot;item.image&quot; :goodsName=&quot;item.name&quot; :goodsPrice=&quot;item.price&quot;&gt;&lt;/goods-info&gt; &lt;/van-col&gt;&lt;/van-row&gt; 编写后台服务接口配置文件在开发中我们直接把数据接口写到了 axios 中，这样写如果地址改变或者接口改变，我们需要进入业务逻辑代码进行修改，维护起来会非常麻烦，现在我们把项目中用到的接口都单独拿出来，做一个接口配置文件 serviceAPI.config.js 编写接口配置文件 在项目 src 目录下建立 serviceAPI.config.js，代码如下： 1234567const BASEURL = &quot;https://www.easy-mock.com/mock/5ae2eeb23fbbf24d8cd7f0b6/SmileVue/&quot;const URL = &#123; getShoppingMallInfo:BASEURL+&apos;index&apos;, getGoodsInfo:BASEURL+&apos;getGoodsInfo&apos;&#125; module.exports = URL 编写好后，就可以直接在要使用的文件中用 import 的形式引入。 import url from ‘@.serviceAPI.config.js’ 引入后就可以直接使用了 1234axios(&#123; url: url.getShoppingMallInfo, method: &apos;get&apos;&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站统计]]></title>
    <url>%2F2018%2F06%2F24%2F%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[网站统计流量统计原理 流量统计原理主要有两种：传统的基于日志文件统计和当前较为流行的基于脚本（JavaScript 等）统计 基于日志文件的统计通过分析网站后台的日志文件来统计访客的浏览和点击行为。这种方法的优点是简单方便，无需修改网页代码，可以 收集网络爬虫数据等。缺点是网站日志包含所有日志数据，需预处理来提升数据质量；而且无法统计到页面缓存导致的缓 存浏览数据。 基于脚本的统计此方法需要在网站的 html 代码中嵌入一段脚本（JavaScript 等）用于统计访客的浏览等行为。这种方法的优点是技 术难度低，只需嵌入脚本代码，无需配置服务器；能够快速获取点击、响应等数据并方便展现；不需要担心缓存带来的影 响，数据的准确度较高。缺点主要是无法统计网络爬虫的信息。当前主流的流量分析系统绝大部分采用此种方法收集数据， 包括百度统计和谷歌分析等。以下为网站分析工具的 JavaScript 收集数据流程图： 网站分析指标网站分析中都用到哪些衡量指标？又如何分析这些指标呢？举个例子来说明，如果把一个网站比作一家超市，运营网 站就像打理超市的生意，那么目标就是让访客多停留、多购买、多办几张会员卡。为了达成这个目标，我们先要了解当前 的情况，比如有多少人走进了超市、看了多少件产品、多少人办理了会员卡；类似地，在网站分析中我们也要了解这些数 据，并作为后续业务调整的依据：比如，多少人进入了网站、浏览了多少页面、多少人办理会员等，网站分析指标是数据 化地呈现网站运营的状况，帮助站长从各维度了解访客，优化网站。 常见指标为：浏览量（PV）、访问次数、访客数（UV）、新访客数、新访客比率、IP、跳出率、平均访问时长、平 均访问页数、转化次数、转化率。可以概况为 3 类，流量数量指标，流量质量指标，流量转化指标。 流量数量指标 浏览量 （PV） 定义：页面浏览量即为 PV(Page View)，用户每打开一个页面就被记录 1 次。 技术说明：一个 PV 即电脑从网站下载一个页面的一次请求。当页面上的 JS 文件加载后，统计系统才会统计到这个 页面的浏览行为，有如下情况需注意：1. 用户多次打开同一页面，浏览量值累计。2. 如果客户端已经有该缓冲的文档， 甚至无论是不是真的有这个页面（比如 JavaScript 生成的一些脚本功能），都可能记录为一个 PV。但是如果利用网站 后台日志进行分析，因为缓存页面可能直接显示而不经过服务器请求，那么不会记录为一个 PV。 涵义：PV 越多越说明该页面被浏览的越多。PV 之于网站，就像收视率之于电视，已成为评估网站表现的基本尺度。 访问次数 定义：访问次数即 Visit，访客在网站上的会话 (Session) 次数，一次会话过程中可能浏览多个页面。 技术说明：如果访客连续 30 分钟内没有重新打开和刷新网站的网页，或者访客关闭了浏览器，则当访客下次访问您 的网站时，访问次数加 1。反之，访客离开后半小时内再返回，则算同一个访次，以上对访客的判断均以 Cookie 为准。 涵义：页面浏览量（PV）是以页面角度衡量加载次数的统计指标，而访问次数（Visit）则是访客角度衡量访问的分析指标。 如果网站的用户黏性足够好，同一用户一天中多次登录网站，那么访问次数就会明显大于访客数。 访客数 （UV） 定义：访客数（UV）即唯一访客数，一天之内网站的独立访客数 ( 以 Cookie 为依据 )，一天内同一访客多次访问网 站只计算 1 个访客。 技术说明：当客户端第一次访问某个网站服务器的时候，网站服务器会给这个客户端的电脑发一个 Cookie，记录访 问服务器的信息。当下一次再访问服务器的时候，服务器就可以直接找到上一次它放进去的这个 Cookie，如果一段时间内， 服务器发现两个访次对应的 Cookie 编号一样，那么这些访次一定就是来自一个 UV 了。 涵义：唯一访客数（UV）是访客维度看访客到达网站的数量。 新访客数 定义：一天的独立访客中，历史第一次访问网站的访客数。 涵义：新访客数可以衡量营销活动开发新用户的效果。 新访客比率 定义：新访客比率 = 新访客数 / 访客数。即一天中新访客数占总访客数的比例。 涵义：整体访客数不断增加，并且其中的新访客比例较高，能表现网站运营在不断进步。就像人体的血液循环一样， 有新鲜的血液不断补充进来，充满活力。 IP 数 定义：一天之内，访问网站的不同独立 IP 个数加和。其中同一 IP 无论访问了几个页面，独立 IP 数均为 1。 涵义：从 IP 数的角度衡量网站的流量。 流量质量指标 跳出率 定义：只浏览了一个页面便离开了网站的访问次数占总的访问次数的百分比，即只浏览了一个页面的访问次数 / 全部 的访问次数汇总。 涵义：跳出率是非常重要的访客黏性指标，它显示了访客对网站的兴趣程度：跳出率越低说明流量质量越好，访客对 网站的内容越感兴趣，这些访客越可能是网站的有效用户、忠实用户。该指标也可以衡量网络营销的效果，指出有多少访 客被网络营销吸引到宣传产品页或网站上之后，又流失掉了，可以说就是煮熟的鸭子飞了。比如，网站在某媒体上打广告 推广，分析从这个推广来源进入的访客指标，其跳出率可以反映出选择这个媒体是否合适，广告语的撰写是否优秀，以及 网站入口页的设计是否用户体验良好。 平均访问时长 定义：平均每次访问在网站上的停留时长，即平均访问时长等于总访问时长与访问次数的比值。 涵义：平均访问时间越长则说明访客停留在网页上的时间越长：如果用户对网站的内容不感兴趣，则会较快关闭网页， 那么平均访问时长就短；如果用户对网站的内容很感兴趣，在网站停留了很长时间，平均访问时长就长。 平均访问页数 定义：平均每次访问浏览的页面数量，平均访问页数 = 浏览量 / 访问次数。 涵义：平均访问页数多说明访客对网站兴趣越大。而浏览信息多也使得访客对网站更加了解，这对网站市场信息的传 递，品牌印象的生成，以至于将来的销售促进都是有好处的。一般来说，会将平均访问页数和平均访问时长这两个指标放 在一起分析，进而衡量网站的用户体验情况。 流量转化指标 转化次数 定义：访客到达转化目标页面，或完成网站运营者期望其完成动作的次数。 涵义：转化就是访客做了任意一项网站管理者希望访客做的事。与网站运营者期望达到的推广目的和效果有关。 转化率 定义：转化率 = 转化次数 / 访问次数。 涵义：转化率即访问转化的效率，数值越高说明越多的访次完成了网站运营者希望访客进行的操作。 网站分析流程 网站分析流程其实就是一个发现问题、分析问题和解决问题的过程。利用规范的分析流程会避免逻辑混乱，更加清晰 和有效地优化网站。以下是总结出来的网站分析流程供大家参考： 明确目标 制定计划 选择系统 部署网站 部署简单 数据全面 功能完备 运行稳定 测量指标 分析现象 改进业务 跟踪问题]]></content>
      <tags>
        <tag>网站统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F05%2F21%2Ftest%2F</url>
    <content type="text"><![CDATA[20182018年4月1日 晴​ 又是犹豫的一天，这之前我已经犹豫了两三个月了，犹豫就像一潭死滞的淤泥，我感觉自己的生命在其中正以几十倍于从前的速度消耗着。这里说的从前是我没有产生那个想法的时候，是基延还没有商业化的时候。 ​ 从写字楼顶层的窗子望出去，城市在下面扩展开来，像一片被剖开的集成电路，我不过是那密密麻麻的纳米线路中奔跑的一个小电子，真的算不了什么，所以我做出的决定也算不了什么，所以决定就可以做出了。像以前多少次一样，决定还是做不出，犹豫还在继续。 ​ 强子又迟到了，带着一股风闯进办公室，他脸上有淤青，脑门上还贴着一块创可贴。但他显得很自豪，昂着头，像贴着一枚勋章。他的办公桌就在我对面，他坐下后没开电脑，直勾勾的看着我，显然等我发问，但我没那个兴趣。 “昨晚电视里看到了吧？”强子兴奋地说。 ​ 他显然是指“生命水面”袭击市中心医院的事，那也是国内最大的基延中心。医院雪白的楼面上出现了两道长长的火烧的黑迹，像如玉的美人脸被脏手摸了一下，很惊心。“生命水面”是众多反基延组织中规模最大的一个，也是最极端的一个，强子就是其中的一员，但我没在电视中看到他，当时，医院外面的人群像愤怒的潮水。 ​ “刚开过会，你知道公司的警告，再这样你的饭碗就没了。”我说。 ​ 基延是基因改造延长生命技术的简称，通过去除人类基因中产生衰老时钟的片段，可将人类的正常寿命延长至三百岁。这项技术在五百年前开始商业应用，现在却演化为一场波及全世界的社会和政治灾难，原因是它太贵了。在这里，一个人的基延价格相当于一座豪华别墅，只有少数人能消费的起。 ​ “我不在乎，”强子说，“对于一个连一百岁都活不到的人来说，我在乎什么？”他说着点上一支烟，办公室里禁止吸烟，他看来是想表示自己真的不在乎。 ​ “嫉妒，嫉妒是一种有害健康的情绪。”我挥手驱散眼前的烟雾说，“以前也有很多人因为交不起医疗费而降低寿命的。” ​ “那不一样，看不起病的人是少数，而现在，百分之九十九的人眼巴巴地看着那百分之一的有钱人活三百岁！我不怕承认嫉妒，是嫉妒在维护着社会公平。”他从办公桌上探身凑近我，“你敢拍胸脯说自己不嫉妒？加入我们吧。” ​ 强子的目光让我打了个寒战，一时间真怀疑他看透了我。是的，我就要成为一个他嫉妒的对象，我就要成为一个基延人了。 ​ 其实我没有多少钱，三十多岁一事无成，还处于职场的最底层。但我是财务人员，有机会挪用资金。经过长期的策划，一切都已完成，现在我只要点一下鼠标，基延所需的那五百万新人民币就能进入我的秘密账户，然后再转到基延中心的账户上。这方面我是个很专业的人，在迷宫般的财务系统中我设置了层层掩护，至少要半年时间，这笔资金的缺口才有可能被发现，那时，我将丢掉工作，将被判刑、被没收全部财产，将承受无数鄙夷的目光…… ​ 但那时的我已经是一个能活三百岁的人了。 可我还在犹豫。 ​ 我仔细研究过法律，按贪污罪量刑，五百万元最多判二十年。二十年后，我前面还有两百多年的诱人岁月。现在的问题是，这么简单的算术题，难道只有我会做吗？事实上只要能进入基延一族，现有法律中除死刑之外的所有罪行都值得一犯。那么，有多少人和我一样处于策划和犹豫中？这想法催我尽快行动，同时也使我畏缩。 ​ 但最让我犹豫的还是简简，这已经是属于理性之外了。在遇到简简之前，我不相信世界上有爱情这回事；在遇到她之后，我不相信世界上除了爱情还有什么，离开她，我活两千年又有什么意思？现在在人生的天平上，一边是两个半世纪的寿命，另一边是离开简简的痛苦，天平几乎是平的。 ​ 部门主管召集开会。从他脸上的表情我就能猜出来，这个会不是安排工作，而是针对个人。果然，主管说他今天想谈谈某些员工的“不能被容忍的”社会行为。我没有转头看强子，但知道他要倒霉了，可主管说出的却是另一个人的名字。 ​ “刘伟，据可靠消息，你加入了IT共和国？” ​ 刘伟点点头，像走上断头台的路易十六般高傲：“这与工作无关，我不希望公司干涉个人自由。” ​ 主管严肃地摇摇头，冲他竖起一根手指：“很少有事情与工作无关的，不要把你们在大学中热衷的那一套带到职场上来，如果一个国家可以在大街上骂总统那叫民主，但要是都不服从老板，那这个公司肯定会崩溃的。” ​ “虚拟国家就要被承认了。” ​ “被谁承认？联合国？还是某个大国？别做梦了。” ​ 其实主管最后的这句话中并没有多少自信。现在，人类社会拥有的领土上分为两部分，一部分是地球各大陆和岛屿，另一部分则是互联网广阔的电子空间。后者以快百倍的速度重复着文明史，在那里，经历了几十年无序的石器时代之后，国家顺理成章地出现了，虚拟国家主要有两个起源，一是各种 聚集了大量ID的BBS，二是那些玩家已经上亿的大型游戏。虚拟国家有着与实体国家相似的元首和议会，甚至拥有只在网上出现的军队。与实体国家以地域和民族划分不同，虚拟国家主要以信仰、爱好和职业为基础组建，每个虚拟国家的成员都遍布全世界，多个虚拟国家构成了虚拟国际，现已拥有二十亿人口，并建立了与实体国际对等的虚拟联合国，成为叠加在传统国家之上的巨大的政治实体。 IT共和国就是虚拟国际中的一个超级大国，人口八千万，还在迅速成长中。这是一个主要由IT工程师组成的国家，有着咄咄逼人的政治诉求，也有着对实体国际产生作用的强大力量。我不知道刘伟在其中的公民身份是什么。据说IT共和国的元首是某个IT公司的普通小职员，相反，也有不止一个实体国家的元首被曝光是某个虚拟国家的普通公民。 主管对大家进行严重警告，不得拥有第二国籍，并阴沉地让刘伟到总经理办公室去一趟，然后宣布散会。我们还没有从座位上起身，一直待在电脑屏幕前的郑丽丽让人头皮发炸地大叫起来，说出大事儿了，让大家看新闻。 ​ 我回到办公桌前，把电脑切换到新闻频道，看到紧急插播的重要新闻。播音员一脸阴霾地宣布，在联合国否决IT共和国要求获得承认的3617号决议被安理会通过后，IT共和国向实体国际宣战，半小时前已经开始了对世界金融系统的攻击。 ​ 我看看刘伟，他对这事好像也很意外。 ​ 画面切换到某个大都市，鸟瞰着高楼间的街道，长长的车流拥堵着，人们从车中和两旁的建筑物中纷纷拥出，像是发生了大地震一般。镜头又切换到一家大型超市，人群像黑色的潮水般涌入，疯狂地争抢货物，一排排货架摇摇欲坠，像被潮水冲散的沙堤。 ​ “这是干什么？”我惊恐在问。 ​ “还不明白吗？！”郑丽丽继续尖叫道，“要均贫富了！所有的人都要一文不名了！快抢吃的呀！！” ​ 我当然明白，但不敢相信噩梦已成现实。传统的纸币和硬币已在三年前停止流通，现在即使在街边小货亭买盒烟也要刷卡。在这个全信息化时代，财富是什么？说到底不过是计算机存储器中的一串串脉冲和磁印。以这座华丽宏伟的写字楼来说，如果相关部门中所有的电子记录都被删除，公司的总裁 即使拿着房产证，也没有谁承认它的所有权。钱是什么？钱不再是王八蛋了，钱只是一串比细菌还小的电磁印记和转瞬即逝的脉冲，对于IT共和国来说，实体世界上近一半的IT从业者都是其公民，抹掉这些印记是很容易的。 ​ 程序员、网络工程师、数据库管理员这类人构成了IT共和国的主体，这个阶层是19世纪的产业大军在21世纪的再现，只不过劳作的部分由肢体变成大脑，繁重程度却有增无减。在浩如烟海的程序代码和迷宫般的网络软硬件中，他们如两百多年前的码头搬运工般背起重负，如妓女般彻夜赶工。信息技术的发展一日千里，除了部分爬到管理层的幸运儿，其他人的知识和技能很快过时，新的IT专业毕业生如饥饿的白蚁般成群涌来，老的人（其实不老，大多三十出头）被挤到一边，被代替和抛弃，但新来者没有丝毫得意，这也是他们中大多数人不算遥远的前景……这个阶层被称作技术无产阶级。 ​ 不要说我们一无所有，我们要把世界格式化！这是被篡改的国际歌歌词。 ​ 我突然像遭雷劈一样，天啊，我的钱，那些现在还不属于我的钱，但即将为我买来两个多世纪生命和生活的钱，要被删除了吗？！但如果一切都格式化了，结果不是都一样吗？我的钱、我的基延，我的梦想……我眼前发黑，无头苍蝇般在办公室中来回走着。 ​ 一阵狂笑使我停下脚步，笑声是郑丽丽里发出的，她在哪里笑得蹲下了。 ​ “愚人节快乐。”冷静的刘伟扫了一眼办公室一脚的网络交换机说。我顺着他的目光看去，发现交互机与公司网络断开了，郑丽丽的笔记本电脑接在上面，充当了服务器。这个婊子！为了这个愚人节笑话，她肯定废了不少劲，主要是做哪些新闻画面，但在这个一个人猫在屋里就能用3D软件做出一部大片的时代，这也算不了什么。 ​ 别人显然并不觉得郑丽丽的玩笑过分了，强子又用那种眼光看着我说：“咋啦，你应该对他们发毛才对啊，你怕什么？”他指指高管们所在的上层。 ​ 我又出了一身冷汗，怀疑他是不是真的看透我了，但我最大的恐惧不在于此。 ​ 世界格式化，真的只是IT共和国中极端分子的疯话？真的只是一个愚人节玩笑？吊着这把悬剑的那根头发还能支持多久？ ​ 一瞬间，我的犹豫像突然打开的强光灯下的黑暗那样消失了，我决定了。 ​ 晚上我约了简简，当我从城市灯海的背景上辩认出她的身影时，坚硬的心又软了下来，她那小小的剪影看上去那么娇弱，像一条随时都会被一阵微风吹灭的烛苗，我怎么能伤害她？！当她走近，我看到她的眼睛时，心中的天平已经完全倾向另一个方向，没有她，我要那两百多年有什么用？时间真的会抚平创伤？那可能不过是两个多世纪漫长的刑罚而已。爱情使我这个极端自私的人又崇高起来。 ​ 但简简先说话了，说出的居然是我原来准备向她说的话，一字不差：“我犹豫了好长时间，我们还是分手吧。” ​ 我茫然地问她为什么。 ​ “很长时间后，当我还年轻时，你已经老了。” ​ 我好半天才理解了她的意思，随即也读懂了她那刚才还令我心碎的哀怨目光，我本以为是她已经看透了我或猜到了些什么。我轻轻笑了起来，很快变成仰天大笑。我真是傻，傻得不透气，也不看看这是个什么时代，也不看看我们前面浮现出怎样的诱惑。笑过之后，我如释重负，浑身轻松地像要飘起来，不过在这同时，我还是真诚的为简简高兴。 ​ “你哪来那么多钱？”我问她。 “只够我一个人的。”她低声说，眼睛不敢看我。 ​ “我知道，没关系，我是说你一个人也要不少钱的。” ​ “父亲给了我一些，一百年时间是够的。我还存了一些钱，到那时利息应该不少了。” ​ 我知道自己又猜错了，她不是要做基延，而是要冬眠。这是另一项已经商业化的生命科学成果，在零下五十摄氏度左右的低温状态，通过药物和体外循环系统使人体的新陈代谢速度降至正常状态的百分之一，人在冬眠中度过一百年时间，生理年龄仅长了一岁。 “生活太累了，也无趣，我只是想逃避。”简简说。 “到一个世纪后就能逃避吗？那时你的学历已经不被承认，也不适应当时的社会，能过得好吗？” ​ “时代总是越来越好的，实在不行我到时候再接着冬眠，还可以做基延，到那时一定很便宜了。” ​ 我和简简默默地分别了。也许，一个世纪后我们还能在相会，但我没向她承诺什么，那时候的她还是她，但我已经是一个经历了一百三十多年沧桑的人了。 ​ 简简的背影消失后，我没再犹豫一刻，拿出手机登录到网银系统，立刻把那五百万元新人民币转到基延中心的账户上。虽然已近午夜，我还是很快收到了中心主任的电话，他说明天就可以开始我的基因改良操作，顺利的话一周就能完成。他还郑重地重复了中心的保密承诺（身份暴露的基延族中，已经有三人被杀）。 ​ “你会为自己的决定庆幸的，”主任说，“因为你将得到的不只是两个多世纪的寿命，可能是永生。” ​ 我明白这点，谁也不知道两个世纪后会出现什么样的技术，也许，到时可以把人的意识和记忆拷贝出来,做成永远不丢失的备份，随时可以灌注到一个新的身体中；也许根本不需要身体，我们的意识在网络中像神一般游荡，通过数量无限的传感器感受着世界和宇宙，这真的是永生了。 ​ 主任接着说：“其实，有了时间就有了一切，只要时间足够，一直乱敲打字机的猴子都能打出《莎士比亚全集》，而你有的是时间。” ​ “我？不是我们吗？” ​ “我没有做基延。” ​ “为什么？” ​ 对方沉默良久后说：“这世界变化太快了，太多的机会、太多的诱惑、太多的欲望、太多的危险，我觉得头晕目眩的，毕竟岁数大了。不过你放心，”他接着说出了简简那句话，“时代总是越来越好的。” ​ 现在，我坐在自己狭小的单身公寓中写这这篇日记，这是我有生以来第一篇日记，以后要坚持记下去，因为我总要留下些东西。时间也会让人失去一切，我知道，长寿的并不是我，两个世纪后的我肯定是另一个陌生人了，其实仔细想想，自我的概念搬来就很可疑，构成自我的身体、记忆和意识都是在不断的变化中，与简简分别之前的我，以犯罪的方式付款之前的我，与主任交谈之前的我，甚至在打出这个“甚至”之前的我，都已经不是同一个人了，想到这里我很释然。 ​ 但我总是要留下些东西。 ​ 窗外的夜空中，黎明前的星星在发出它们最后的寒光，与城市辉煌的灯海相比，星星如此暗淡，刚能被辨认出来，但他们是永恒的象征。就在这一夜，不知有多少与我一样的新新人类上路了，不管好坏，我们将是第一批真正触摸永恒的人。]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
